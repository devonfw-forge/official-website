<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hexagonal Architecture :: devonfw</title>
    <link rel="canonical" href="https://devonfw.com/docs/java/current/architecture/hexagonal_architecture.html">
    <meta name="generator" content="Antora 3.0.2">
    <link rel="stylesheet" href="../../../_/css/site.css">
<meta property="og:title" content="1/architecture/hexagonal_architecture.adoc" />    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://devonfw.com/">devonfw</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
    <div class="navbar-end">
        <a class="navbar-item" href="https://devonfw.com/docs/java/current/">Java</a>
        <a class="navbar-item" href="https://devonfw.com/docs/typescript/current/">TypeScript</a>
        <a class="navbar-item" href="https://github.com/devonfw/ide">IDE</a>
        <a class="navbar-item" href="https://github.com/devonfw/hangar">CI/CD</a>
        <a class="navbar-item" href="https://devonfw.com/website/pages/learning/">Tutorials</a>
        <a class="navbar-item" href="https://devonfw.com/website/pages/docs/master.html">Legacy Docs</a>
          <div class="navbar-item search hide-for-print">
            <div id="search-field" class="field">
              <input id="search-input" type="text" placeholder="Search the docs">
            </div>
          </div>
        <a class="navbar-github navbar-item" href="https://github.com/devonfw/"></a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="java" data-version="1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Java</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../getting_started/getting_started.html">Getting started</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../getting_started/create_rest_service.html">Create a REST service</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Architecture</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="layered_architecture.html">Layered Architecture</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="hexagonal_architecture.html">Hexagonal Architecture</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Integration</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../integration/rest_service.html">REST</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../integration/rest_exception_handling.html">RESTful Exception Handling</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../integration/rest_service_json.html">JSON</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../integration/rest_openapi.html">Open Api Generator</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Persistence</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Relational Databases</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../persistence/jpa.html">JPA</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../persistence/transactional.html">Transaction</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Cross cutting</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cross_cutting/coding_conventions.html">Coding Conventions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cross_cutting/configuration.html">Configuration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cross_cutting/dependency_injection.html">Dependency Injection</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cross_cutting/exceptions.html">Exceptions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cross_cutting/i18n.html">Internationalization (I18N)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cross_cutting/oauth2_proxy.html">Authentication with Keycloak using a OAuth 2 Proxy</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cross_cutting/logging.html">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Security</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../cross_cutting/security/authentication.html">Authentication</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../cross_cutting/security/authorization.html">Authorization</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../cross_cutting/security/cors.html">CORS</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../cross_cutting/security/csrf.html">CSRF</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cross_cutting/tracing.html">Tracing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../cross_cutting/test_automation/test_automation.html">Test Automation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../cross_cutting/test_automation/unit_tests.html">Unit Tests</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../cross_cutting/test_automation/sub_system_tests.html">Subsystem- and System-Tests</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../cross_cutting/test_automation/contract_tests.html">Consumer Driven Contract (CDC) Tests</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../cross_cutting/test_automation/architecture_tests.html">Architecture Tests</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Examples</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../examples/my-thai-star.html">My-Thai-Star Sample Application</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Java</span>
    <span class="version">1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Java</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../typescript/current/index.html">Typescript</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../typescript/current/index.html">1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Java</a></li>
    <li>Architecture</li>
    <li><a href="hexagonal_architecture.html">Hexagonal Architecture</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/devonfw/java/edit/main/modules/ROOT/pages/architecture/hexagonal_architecture.adoc">Contribute to this page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div id="contribution-overlay" class="contribution-overlay"></div>
<div id="contribution-div" class="contribution">
  <button id="contribution-btn" class="contribution-btn"><span class="close">&times</span></button>
  <div class="contribution-container">
      <div class="contribution-img"> </div>
      <h2> Contribute to help us improve!</h2> 
      <p> Are there edge cases or problems that we didn't consider? Is there a technical pitfall that we should add? Did we miss a comma in a sentence? </p>
      <p> If you have any input for us, we would love to hear from you and appreciate every contribution. Our goal is to learn from projects for projects such that nobody has to reinvent the wheel. </p>
      <p> Let's collect our experiences together to make room to explore the novel! </p> 
      <p> To contribute click on <span class="devonfw-primary-color">Contribute to this page</span> on the toolbar.</p>
  </div>
</div><h1 class="page">Hexagonal Architecture</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Hexagonal architecture, also known as Ports and Adapters, is a software design pattern that promotes separation of concerns by organizing an application into a central core surrounded by external adapters.
The core contains the business logic and communicates with the external world via well-defined ports (interfaces).
Adapters implement these ports and handle the translation between the core&#8217;s domain model and the specific technologies or protocols used by external systems.</p>
</div>
<div id="img-t-hexagonal-architecture" class="imageblock text-center">
<div class="content">
<img src="../_images/hexagonal_component_architecture_overview.drawio.svg" alt="devonfw hexagonal architecture blueprint">
</div>
<div class="title">Figure 1. Hexagonal Architecture Reference</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plaintext hljs" data-lang="plaintext">.
└── application/
    ├── core/
    │   ├── domain/
    │   │   ├── Customer.java
    │   │   ├── CustomerFactory.java
    │   │   ├── Reservation.java
    │   │   └── Table.java
    │   ├── ports/
    │   │   ├── in/
    │   │   │   ├── AddReservationPort.java
    │   │   │   ├── CancelReservationPort.java
    │   │   │   ├── AlterReservationPort.java
    │   │   │   ├── AddTablePort.java
    │   │   │   └── RemoveTablePort.java
    │   │   └── out/
    │   │       └── StoreReservationPort.java
    │   ├── usecase/
    │   │   ├── AddReservationUc.java
    │   │   ├── ManageReservationUc.java
    │   │   └── AddTableUc.java
    │   └── [service]/
    │       └── [FindFreeTableService.java]
    └── adapter/
        ├── in/
        │   └── web/
        │       ├── RestController.java
        │       ├── model/
        │       │   └── ReservationDto.java
        │       └── mapper/
        │           └── ReservationMapper.java
        └── out/
            └── repository/
                ├── JpaAdapter.java
                ├── model/
                │   ├── ReservationEntity.java
                │   └── TableEntity.java
                └── mapper/
                    ├── ReservationJpaMapper.java
                    └── TableJpaMapper.java</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Package</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">core</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The core contains the essential business logic, domain entities, and use cases. It focuses on implementing the main functionalities while remaining technology-agnostic. The core interacts with external components through well-defined interfaces called "ports," ensuring a clear separation of concerns and promoting flexibility, testability, and maintainability.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">core.domain</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The domain package contains the entities and value objects of the business domain of the application.
Related Factories or Builders are located here as well.
It&#8217;s proposed to make entities anemic. See <a href="#_anemic_vs_rich_domain_models">Anemic vs Rich domain models</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">core.usecase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use Cases are the main entrypoint of the applications core.
They validate the given input and orchestrate the domain entities, services and ports to implement a Business Use Case.
Usually a use case implementation should only include a small dedicated use case.
Depending of the size and adjacency of the use cases a grouping might make sense (e.g. ManageTableUc)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">core.port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ports are interfaces, that are used by the core and should be implemented by an according adapter.
Ports should not be technology specific.
One big advantage of the hexagonal architecture is, that the adapters can be changed without changing the core and therefore, without touching the business logic.
It needs to be distinguished between incoming ports and outgoing ports.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">core.port.in</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Incoming ports are the entry of the application.
They provide interfaces that are called from incoming adapters and hide the actual implementation.
A proposal of structuring incoming ports is naming them like single use cases (e.g. CancelReservationPort).
Each port should only provide a single method.</p>
</div>
<details>
<summary class="title">Design Decision</summary>
<div class="content">
<div class="paragraph">
<p>Incoming Ports are not as relevant for the hexagonal architecture as the outgoing ports.
Outgoing ports are used for the dependency inversion pattern.
For incoming ports could also call the use cases directly.
Therefore, an pragmatic alternative would be leaving out the incoming ports.</p>
</div>
<div class="paragraph">
<p>It was decided to include the incoming ports nonetheless. They should implement single use cases that are offered.
Each interface should clearly mark the use case that contains only one method.
Use cases from the interface might be grouped logically in the use case implementation class.</p>
</div>
</div>
</details></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">core.port.out</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Outgoing ports are an abstraction of everything in the surrounding context that is actively triggered by the core or used as data sink.
This might include other services that are called, files that are written, databases, event streaming and everything the application is actively triggering outside of the core.
Outgoing ports should describe the business need for the communication (e.g. StoreReservationPort). How this is then realized depends on the adapter that implements it.
This way a technology can be easily replaced.
For example storing the reservation could be be realized in a first prototype by writing the objects to a file.
Later it could be replaced with a database.
The core logic would be untouched by that.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[optional] core.service</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Services can be considered as business helper classes.
They provide a reusable part of the applications business logic that is used by multiple use cases or that helps to structure the application in a logical way.
Services are optional as they can be used, when there&#8217;s a real need.
Usually a use case should contain the business logic.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">adapter</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Adapters connect the application core to the surrounding context. They have the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Implement a specific protocol to connect to the context. E.g REST, JDBC, MQTT, &#8230;&#8203;</p>
</li>
<li>
<p>Maintain a data model that is necessary to communicate with the context</p>
</li>
<li>
<p>Translate the domain model from the core to that model or vice versa</p>
</li>
<li>
<p>Handle protocol specific errors</p>
</li>
<li>
<p>Log the interaction with the surrounding context</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">adapter.in</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Incoming adapters specify connection points for everything that can trigger the business logic.
That might be interfaces (HTML, RPC, etc), Message Consumers or schedulers for batch processing.
Inside the adapters further packages are differentiating the category of the adapter (e.g. <code>.web</code>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">adapter.out</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Outgoing adapters define outgoing connections where the application actively interacts with context outside.
That can be database connections, file operations, API calls, message producing and many more.
Inside the adapters further packages are differentiating the category of the adapter (e.g. <code>.repository</code>).</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_anemic_vs_rich_domain_models"><a class="anchor" href="#_anemic_vs_rich_domain_models"></a>Anemic vs Rich domain models</h2>
<div class="sectionbody">
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>"In a rich domain model, as much of the domain logic as possible is implemented within the entities at the core of the application.
The entities provide methods to change state and only allow changes that are valid according to the business rules. [&#8230;&#8203;]
In an “anemic” domain model, the entities themselves are very thin.
They usually only provide fields to hold." <a href="#Hombergs21">[Hombergs21]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Considering java as an object oriented language it feels natural to implement business logic inside the entities themselves.
In large scale application we propose to not use rich domain models.
There are two reasons for this:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>the domain objects are returned to the adapters.
If they include business logic this is revealed and available outside of the core, which should not be the case.
The answer to this problem could be an additional mapping, but this leads to a lot of unpractical mappings.</p>
</li>
<li>
<p>adding the business logic to the domain entities spreads it across use cases, entities and services.
This makes the application more difficult to understand and harder to locate the place for new features or changes.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Therefore, we propose to implement the domain model as anemic entities and make usage of use cases and services to implement the business logic and interact with the domain models.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_module_based_hexagonal_component_architecture"><a class="anchor" href="#_module_based_hexagonal_component_architecture"></a>Module-based hexagonal component architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The previously described approach of using packages to maintain a hexagonal architecture is particularly suitable for lightweight and smaller applications.</p>
</div>
<div class="paragraph">
<p>For larger applications, it makes sense to additionally implement the division using Maven or Gradle modules.
This has the advantage that the application core of the hexagon remains completely without special technical frameworks such as JPA.
As a result, it is technically not possible to use these functions in the core, which permanently leads to a "cleaner" core.</p>
</div>
<div class="paragraph">
<p>The division into modules looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plaintext hljs" data-lang="plaintext">application A1
├── bootstrap (module)
└── business component C1 (module)
    ├── core (module)
    │   ├── domain
    │   ├── port
    │   │   ├── in
    │   │   └── out
    │   ├── usecase
    │   └── service (optional)
    └── adapter (module)
        ├── in
        │   └── web
        │       └── (analog with packages)
        └── out
            └── repository
                └── (analog with packages)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Within the application we structure the individual business components using modules.
The main purpose of this is to have a structure that is future-proof and allows multiple business components to be integrated.
Modules at this level have the advantage that they can be developed independently and communication must be explicitly regulated.
For the sake of simplicity, we initially only assume one business component.
The business component is in turn divided into two further modules <code>core</code> and <code>adapter</code>.
This separation allows the dependencies for both modules to be independent of each other and the core to remain free of technical frameworks.
The direction of communication is also clearly regulated by the dependencies between core and adapter.
In addition to the module for the business component, there is a <code>bootstrap</code> module that can be seen as a starting point for the application.
When using Spring Boot, the <code>SpringBootApplication</code> and configurations can also be found here.
This module in turn has a dependency on all business components (to be precise on their core and adapter).</p>
</div>
<div class="paragraph">
<p>The adapter module contains all incoming and outgoing adapters of a business component.
This offers a good compromise between structuring and tailor-made dependencies and manageable complexity on the other hand.
Therefore, we suggest to structure the adapter module using packages to differentiate incoming and outgoing adapters and on the next level the specifics of adapters like web, repository, etc.
See the package project structure to get the full picture.
Given the usual level of complexity, it can be assumed that there are usually no more than 2-3 adapters, so structuring using packages is sufficient here.
As complexity increases, two additional options become available:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Separate modules for in and out. This allows the frameworks for incoming and outgoing adapters to be maintained separately and provides an additional level of structuring.</p>
</li>
<li>
<p>Individual modules for each adapter. This means that each adapter can be viewed and developed completely isolated.
The dependencies can also be maintained independently.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With both options, the complexity of managing modules and explicit dependencies increases accordingly.
The recommendation is to start with a package structure and divide it further if necessary.</p>
</div>
<div class="paragraph">
<p>Dependencies should be defined as far "down" as possible and not on the root or business component level.
In particular, technical frameworks such as JPA should be defined directly in the adapter module so that they are not available in the core module.
In order to keep versions consistent, <a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management">dependency management</a> in the master pom can be used in Maven.
The advantage of this is that the version only needs to be defined at the main level and does not need to be specified in every adapter pom.
This approach also prevents the same framework from being used in different versions in the adapters.</p>
</div>
<div class="paragraph">
<p>It is necessary that the adapters can access the core and therefore have a dependency so that, on the one hand, incoming adapters can call logic in the core and, on the other hand, outgoing adapters from the core can be used.
The latter is only possible via dependency inversion, as the core is not allowed to access the outgoing adapter directly.
In this case, the out ports in the core are defined and used as an interface.
The dependency injection framework in Spring or Quarkus then determines in the background the appropriate implementation from the out adapters that implement the out port interface.
In this way, it is possible for the core to call functionality in the adapters without having a dependency in this direction.
Under no circumstances should there be a dependency from the core to the adapter.
This would undermine the fundamental principle of a hexagonal architecture and destroy the benefits of it</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In case you are using Quarkus environment the dependency inversion is not possible out of the box.
That means that outgoing ports cannot injected as expected which causes errors during application start.
In that case you can inject outgoing ports with <code>Instance&lt;YourOutgoingPort&gt;</code> which decouples the injection process.
You can find detailed information about it <a href="https://quarkus.io/guides/cdi#hm-wait-a-minute-what-happens-if-multiple-beans-declare-the-same-type">here</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_multiple_business_components_in_modulithic_high_level_architecture"><a class="anchor" href="#_multiple_business_components_in_modulithic_high_level_architecture"></a>Multiple business components in modulithic high-level architecture</h3>
<div class="paragraph">
<p>So far we have assumed one business component and therefore also one module that includes core and adapter.
As functional complexity increases, additional business components/modules are added.</p>
</div>
<div class="paragraph">
<p>The modulith approach is particularly useful if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the scaling requirements of the functional components are similar</p>
</li>
<li>
<p>additional complexity due to communication between services is (currently) not desired</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For new functional components, a new module must be added at the main level.
Its substructure is analogous to the module described previously.
This module must also be added as a dependency in the bootstrap module.</p>
</div>
<div id="img-t-hexagonal-architecture-modules" class="imageblock text-center">
<div class="content">
<img src="../_images/hexagonal_component_architecture_modules2.drawio.svg" alt="devonfw hexagonal architecture modules">
</div>
<div class="title">Figure 2. Module-based hexagonal component architecture with multiple modules</div>
</div>
<div class="paragraph">
<p>A crucial aspect of several business components is their communication with each other.
For example, it is necessary for business component C1 to communicate with component C2.
Since the business components are within one application, it is not necessary to use communication technologies such as REST.
JVM based adapters can be used instead.
In the simplest case, these can be achieved with synchronous communication using direct procedure calls.
In the case of asynchronous communication, internal message providers such as <a href="https://www.baeldung.com/spring-events">Spring Events</a> can be used.
These enable decoupling through events at the JVM level and are particularly useful if you plan to later distribute the business components across several applications.</p>
</div>
<div class="paragraph">
<p>To enable communication between the business components, the following steps must be followed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a Maven dependency from adapter C1 to adapter C2 need to be added</p>
</li>
<li>
<p>an <code>JVM In adapter</code> is created in component C2, which provides an interface, defines transport objects (TO) and enables these TOs to be mapped to the domain objects in the core of component C2.</p>
</li>
<li>
<p>an <code>JVM out adapter</code> is created in component C1, which maps the domain objects from the core of component C1 into a transport object (defined in adapter C2, see previous step) and then calls the interface of adapter C2.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plaintext hljs" data-lang="plaintext">application A1
├── bootstrap (module)
├── business component C1 (module)
│   ├── core (module)
│   │   └── ...
│   └── adapter (module)
│       ├── in
│       │   └── web
│       │       └── ...
│       └── out
│           ├── repository
│           │   └── ...
│           └── jvm
│               └── component C2
│                   ├── mapper
│                   │   └── BookingMapper.java
│                   └── BookingComponentC1OutAdapter.java
└── business component C2 (module)
    ├── core (module)
    │   └── ...
    └── adapter (module)
        ├── in
        │   ├── event
        │   │   └── ...
        │   └── jvm
        │       └── component C1
        │           ├── model
        │           │   └── BookingUpdateDto.java
        │           └── BookingComponentC1InAdapter.java
        └── out
            └── repository
                └── ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this way, the two business components can communicate with each other within a modular architecture.
At first glance, this seems complex and may involve overhead, since, for example, two mappings have to be implemented.
However, this is deliberately chosen because, on the one hand, it means that communication between business components is used consciously and only where really necessary.
On the other hand, these adapters represent a predetermined breaking point for later division.
More on this in the next section.</p>
</div>
</div>
<div class="sect2">
<h3 id="_extract_business_components_into_microservices"><a class="anchor" href="#_extract_business_components_into_microservices"></a>Extract business components into microservices</h3>
<div class="paragraph">
<p>Increasing technical complexity or changing scaling requirements may make it necessary to (partially) convert the existing module structure into a microservice architecture over time.
The previously selected structure of the hexagonal architecture and the explicit communication via JVM adapters enable such a transformation with relatively little effort.
The decisive advantage is that communication takes place beforehand via firmly defined interfaces.
These now have to be switched from a jvm-based communication to a communication technology e.g. REST.</p>
</div>
<div id="img-t-hexagonal-architecture-microservices" class="imageblock text-center">
<div class="content">
<img src="../_images/hexagonal_component_architecture_microservices.drawio.svg" alt="devonfw hexagonal architecture microservices">
</div>
<div class="title">Figure 3. Module-based hexagonal component architecture with microservices</div>
</div>
<div class="paragraph">
<p>Based on the previous example, business components C1 and C2 should now be divided into separate microservices.
The transformation includes the following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a new application A2 with module structure as described previously with the Bootstap module (and no business component yet).</p>
</li>
<li>
<p>Remove business component C2 from the existing application A1 and transfer it to application A2 created in the previous step.</p>
</li>
<li>
<p>Adjustment of the Maven dependencies analogous to the specifications described previously.
Additional adapter dependencies, for example for REST or event-based communication.</p>
</li>
<li>
<p>Reimplementation of the previous JVM adapters with the new communication technology.
This also means that there is no uniform Transfer Object (TO), but this must be defined on both the outgoing and incoming sides.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>After the transformation has been completed, the two business components are separated into two applications / microservices.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is important to note that this only highlights the benefits of a module-based hexagonal architecture and how it can be transformed into microservices.
During the transition, a variety of other aspects such as database split, distributed logging and tracing, resilient communication or distributed transactions must be taken into account.
These will not be considered further here and are independent of the backend architecture chosen.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course, a combination of the options mentioned above (package-based, module-based, microservice-based) is also possible.
However, the recommendation is that, especially in larger contexts with several business components, at least modules (Maven or Gradle) are used and communication is carried out via adapters.
This increases maintainability permanently and also enables later transformation into microservices.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bibliography"><a class="anchor" href="#_bibliography"></a>Bibliography</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="Hombergs21"></a>[Hombergs21] Tom Hombergs. <em>Get Your Hands Dirty on Clean Architecture.</em> 2021.</p>
</li>
</ul>
</div>
</div>
</div>
<hr>
<div id="giscus-div">
  <script src="https://giscus.app/client.js"
          data-repo="devonfw/java"
          data-repo-id="R_kgDOISza8Q"
          data-category="Feedback"
          data-category-id="DIC_kwDOISza8c4CSzPy"
          data-mapping="og:title"
          data-strict="0"
          data-reactions-enabled="1"
          data-emit-metadata="0"
          data-input-position="bottom"
          data-theme="light"
          data-lang="en"
          crossorigin="anonymous"
          async>
  </script>
<div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <div class="bottom-footer">
    <ul>
      <li><a href="https://devonfw.com/website/pages/docs/devonfw-guide_ide.wiki_LICENSE.asciidoc.html">Terms of use</a></li>
    </ul>
  </div>
</footer>
<script src="https://cginternal.devonfw.com/communitycontent/main.js"></script>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../.." data-snippet-length="100" data-stylesheet="../../../_/css/search.css"></script>
<script async src="../../../search-index.js"></script>
  </body>
</html>
