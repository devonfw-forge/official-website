{"type":"doc","filename":"devonfw-guide_cobigen.wiki_master-cobigen.asciidoc_cobigen.html","anchor":"devonfw-guide_cobigen.wiki_master-cobigen.asciidoc_plug-ins","title":"Plug-ins","breadcrumbs":["Tools","CobiGen — Code-based incremental Generator","CobiGen"],"text":"Plug-ins\n\n\nJava Plug-in\n\nThe CobiGen Java Plug-in comes with a new input reader for java artifacts, new java related trigger and matchers, as well as a merging mechanism for Java sources.\n\n\nTrigger extension\n\nThe Java Plug-in provides a new trigger for Java related inputs. It accepts different representations as inputs (see Java input reader) and provides additional matching and variable assignment mechanisms. The configuration in the context.xml for this trigger looks like this:\n\n\n\n\ntype 'java'\n\nListing 135. Example of a java trigger definition\n\n\n\n\n\nThis trigger type enables Java elements as inputs.\n\n\n\n\n\nMatcher types\n\nWith the trigger you might define matchers, which restrict the input upon specific aspects:\n\n\n\n\ntype fqn → full qualified name matching\n\nListing 136. Example of a java trigger definition with a full qualified name matcher\n\n\n\n\n\nThis trigger will be enabled if the full qualified name (fqn) of the declaring input class matches the given regular expression (value).\n\n\n\ntype 'package' → package name of the input\n\nListing 137. Example of a java trigger definition with a package name matcher\n\n\n\n\n\nThis trigger will be enabled if the package name (package) of the declaring input class matches the given regular expression (value).\n\n\n\ntype 'expression'\n\nListing 138. Example of a java trigger definition with a package name matcher\n\n\n\n\n\nThis trigger will be enabled if the expression evaluates to true. Valid expressions are\n\n\n\ninstanceof fqn: checks an 'is a' relation of the input type\n\n\nisAbstract: checks, whether the input type is declared abstract\n\n\n\n\n\nContainer Matcher types\n\nAdditionally, the java plugin provides the ability to match packages (containers) as follows:\n\n\n\n\ntype 'package'\n\nListing 139. Example of a java trigger definition with a container matcher for packages\n\n\n\n\n\nThe container matcher matches packages provided by the type com.capgemini.cobigen.javaplugin.inputreader.to.PackageFolder with a regular expression stated in the value attribute. (See containerMatcher semantics to get more information about containerMatchers itself.)\n\n\n\n\n\n\nVariable Assignment types\n\nFurthermore, it provides the ability to extract information from each input for further processing in the templates. The values assigned by variable assignments will be made available in template and the destinationPath of context.xml through the namespace variables.&lt;key&gt;. The Java Plug-in currently provides two different mechanisms:\n\n\n\n\ntype 'regex' → regular expression group\n\n\n\n\n\n\n\n\n\nThis variable assignment assigns the value of the given regular expression group number to the given key.\n\n\n\n\ntype 'constant' → constant parameter\n\n\n\n\n\n\n\n\n\nThis variable assignment assigns the value to the key as a constant.\n\n\n\nJava input reader\n\nThe CobiGen Java Plug-in implements an input reader for parsed java sources as well as for java Class&lt;?&gt; objects (loaded by reflection). So API user can pass Class&lt;?&gt; objects as well as JavaClass objects for generation. The latter depends on QDox, which will be used for parsing and merging java sources. For getting the right parsed java inputs you can easily use the JavaParserUtil, which provides static functionality to parse java files and get the appropriate JavaClass object.\n\n\nFurthermore, due to restrictions on both inputs according to model building (see below), it is also possible to provide an array of length two as an input, which contains the Class&lt;?&gt; as well as the JavaClass object of the same class.\n\n\nTemplate object model\n\nNo matter whether you use reflection objects or parsed java classes as input, you will get the following object model for template creation:\n\n\n\n\nclassObject ('Class' :: Class object of the Java input)\n\n\nPOJO\n\n\n\nname ('String' :: Simple name of the input class)\n\n\npackage ('String' :: Package name of the input class)\n\n\ncanonicalName ('String' :: Full qualified name of the input class)\n\n\nannotations ('Map&lt;String, Object&gt;' :: Annotations, which will be represented by a mapping of the full qualified type of an annotation to its value. To gain template compatibility, the key will be stored with '_' instead of '.' in the full qualified annotation type. Furthermore, the annotation might be recursively defined and thus be accessed using the same type of mapping. Example ${pojo.annotations.javax_persistence_Id})\n\n\nJavaDoc ('Map&lt;String, Object&gt;') :: A generic way of addressing all available JavaDoc doclets and comments. The only fixed variable is comment (see below). All other provided variables depend on the doclets found while parsing. The value of a doclet can be accessed by the doclets name (e.g. ${…​JavaDoc.author}). In case of doclet tags that can be declared multiple times (currently @param and @throws), you will get a map, which you access in a specific way (see below).\n\n\n\ncomment ('String' :: JavaDoc comment, which does not include any doclets)\n\n\nparams ('Map&lt;String,String&gt; :: JavaDoc parameter info. If the comment follows proper conventions, the key will be the name of the parameter and the value being its description. You can also access the parameters by their number, as in arg0, arg1 etc, following the order of declaration in the signature, not in order of JavaDoc)\n\n\nthrows ('Map&lt;String,String&gt; :: JavaDoc exception info. If the comment follows proper conventions, the key will be the name of the thrown exception and the value being its description)\n\n\n\n\n\nextendedType ('Map&lt;String, Object&gt;' :: The supertype, represented by a set of mappings (since cobigen-javaplugin v1.1.0)\n\n\n\nname ('String' :: Simple name of the supertype)\n\n\ncanonicalName ('String' :: Full qualified name of the supertype)\n\n\npackage ('String' :: Package name of the supertype)\n\n\n\n\n\nimplementedTypes ('List&lt;Map&lt;String, Object&gt;&gt;' :: A list of all implementedTypes (interfaces) represented by a set of mappings (since cobigen-javaplugin v1.1.0)\n\n\n\ninterface ('Map&lt;String, Object&gt;' :: List element)\n\n\n\nname ('String' :: Simple name of the interface)\n\n\ncanonicalName ('String' :: Full qualified name of the interface)\n\n\npackage ('String' :: Package name of the interface)\n\n\n\n\n\n\n\n\nfields ('List&lt;Map&lt;String, Object&gt;&gt;' :: List of fields of the input class) (renamed since cobigen-javaplugin v1.2.0; previously attributes)\n\n\n\nfield ('Map&lt;String, Object&gt;' :: List element)\n\n\n\nname ('String' :: Name of the Java field)\n\n\ntype ('String' :: Type of the Java field)\n\n\ncanonicalType ('String' :: Full qualified type declaration of the Java field’s type)\n\n\n'isId' (Deprecated :: boolean :: true if the Java field or its setter or its getter is annotated with the javax.persistence.Id annotation, false otherwise. Equivalent to ${pojo.attributes[i].annotations.javax_persistence_Id?has_content})\n\n\nJavaDoc (see pojo.JavaDoc)\n\n\nannotations (see pojo.annotations with the remark, that for fields all annotations of its setter and getter will also be collected)\n\n\n\n\n\n\n\n\nmethodAccessibleFields ('List&lt;Map&lt;String, Object&gt;&gt;' :: List of fields of the input class or its inherited classes, which are accessible using setter and getter methods)\n\n\n\nsame as for field (but without JavaDoc!)\n\n\n\n\n\nmethods ('List&lt;Map&lt;String, Object&gt;&gt;' :: The list of all methods, whereas one method will be represented by a set of property mappings)\n\n\n\nmethod ('Map&lt;String, Object&gt;' :: List element)\n\n\n\nname ('String' :: Name of the method)\n\n\nJavaDoc (see pojo.JavaDoc)\n\n\nannotations (see pojo.annotations)\n\n\n\n\n\n\n\n\n\n\n\n\n\nFurthermore, when providing a Class&lt;?&gt; object as input, the Java Plug-in will provide additional functionalities as template methods (deprecated):\n\n\n\n\nisAbstract(String fqn) (Checks whether the type with the given full qualified name is an abstract class. Returns a Boolean value.) (since cobigen-javaplugin v1.1.1)  (deprecated)\n\n\nisSubtypeOf(String subType, String superType) (Checks whether the subType declared by its full qualified name is a sub type of the superType declared by its full qualified name. Equals the Java expression subType instanceof superType and so also returns a Boolean value.) (since cobigen-javaplugin v1.1.1)  (deprecated)\n\n\n\n\n\nModel Restrictions\n\nAs stated before both inputs (Class&lt;?&gt; objects and JavaClass objects ) have their restrictions according to model building. In the following these restrictions are listed for both models, the ParsedJava Model which results from an JavaClass input and the ReflectedJava Model, which results from a Class&lt;?&gt; input.\n\n\nIt is important to understand, that these restrictions are only present if you work with either Parsed Model OR the Reflected Model. If you use the Maven Build Plug-in or Eclipse Plug-in these two models are merged together so that they can mutually compensate their weaknesses.\n\n\nParsed Model\n\n\n\nannotations of the input’s supertype are not accessible due to restrictions in the QDox library. So pojo.methodAccessibleFields[i].annotations will always be empty for super type fields.\n\n\nannotations' parameter values are available as Strings only (e.g. the Boolean value true is transformed into \"true\"). This also holds for the Reflected Model.\n\n\nfields of \"supertypes\" of the input JavaClass are not available at all. So pojo.methodAccessibleFields will only contain the input type’s and the direct superclass’s fields.\n\n\n[resolved, since cobigen-javaplugin 1.3.1] field types of supertypes are always canonical. So pojo.methodAccessibleFields[i].type will always provide the same value as pojo.methodAccessibleFields[i].canonicalType (e.g. java.lang.String instead of the expected String) for super type fields.\n\n\n\n\n\nReflected Model\n\n\n\nannotations' parameter values are available as Strings only (e.g. the Boolean value true is transformed into \"true\"). This also holds for the Parsed Model.\n\n\nannotations are only available if the respective annotation has @Retention(value=RUNTIME), otherwise the annotations are to be discarded by the compiler or by the VM at run time. For more information see RetentionPolicy.\n\n\ninformation about generic types is lost. E.g. a field’s/ methodAccessibleField’s type for List&lt;String&gt; can only be provided as List&lt;?&gt;.\n\n\n\n\n\n\n\n\nMerger extensions\n\nThe Java Plug-in provides two additional merging strategies for Java sources, which can be configured in the templates.xml:\n\n\n\n\nMerge strategy javamerge (merges two Java resources and keeps the existing Java elements on conflicts)\n\n\nMerge strategy javamerge_override (merges two Java resources and overrides the existing Java elements on conflicts)\n\n\n\n\nIn general merging of two Java sources will be processed as follows:\n\n\nPrecondition of processing a merge of generated contents and existing ones is a common Java root class resp. surrounding class. If this is the case this class and all further inner classes will be merged recursively. Therefore, the following Java elements will be merged and conflicts will be resolved according to the configured merge strategy:\n\n\n\n\nextends and implements relations of a class: Conflicts can only occur for the extends relation.\n\n\nAnnotations of a class: Conflicted if an annotation declaration already exists.\n\n\nFields of a class: Conflicted if there is already a field with the same name in the existing sources. (Will be replaced / ignored in total, also including annotations)\n\n\nMethods of a class: Conflicted if there is already a method with the same signature in the existing sources. (Will be replaced / ignored in total, also including annotations)\n\n\n\n\n\n\n\nProperty Plug-in\n\nThe CobiGen Property Plug-in currently only provides different merge mechanisms for documents written in Java property syntax.\n\n\nMerger extensions\n\nThere are two merge strategies for Java properties, which can be configured in the templates.xml:\n\n\n\n\nMerge strategy propertymerge (merges two properties documents and keeps the existing properties on conflicts)\n\n\nMerge strategy propertymerge_override (merges two properties documents and overrides the existing properties on conflicts)\n\n\n\n\nBoth documents (base and patch) will be parsed using the Java 7 API and will be compared according their keys. Conflicts will occur if a key in the patch already exists in the base document.\n\n\n\n\n\nXML Plug-in\n\nThe CobiGen XML Plug-in comes with an input reader for XML artifacts, XML related trigger and matchers and provides different merge mechanisms for XML result documents.\n\n\nTrigger extension\n\n(since cobigen-xmlplugin v2.0.0)\n\n\nThe XML Plug-in provides a trigger for XML related inputs. It accepts XML documents as input (see XML input reader) and provides additional matching and variable assignment mechanisms. The configuration in the context.xml for this trigger looks like this:\n\n\n\n\ntype 'xml'\n\nListing 140. Example of a XML trigger definition.\n\n\n\n\n\nThis trigger type enables XML documents as inputs.\n\n\n\ntype xpath\n\nListing 141. Example of a xpath trigger definition.\n\n\n\n\n\nThis trigger type enables XML documents as container inputs, which consists of several sub-documents.\n\n\n\n\n\nContainer Matcher type\n\nA ContainerMatcher check if the input is a valid container.\n\n\n\n\nxpath: type: xpath\n\nListing 142. Example of a XML trigger definition with a node name matcher.\n\n\n\n\n\nBefore applying any Matcher, this containerMatcher checks if the XML file contains a node uml:Model with a childnode packagedElement which contains an attribute xmi:type with the value uml:Class.\n\n\n\n\n\n\nMatcher types\n\nWith the trigger you might define matchers, which restrict the input upon specific aspects:\n\n\n\n\nXML: type nodename → document’s root name matching\n\nListing 143. Example of a XML trigger definition with a node name matcher\n\n\n\n\n\nThis trigger will be enabled if the root name of the declaring input document matches the given regular expression (value).\n\n\n\nxpath: type: xpath → matching a node with a xpath value\n\nListing 144. Example of a xpath trigger definition with a xpath matcher.\n\n\n\n\n\nThis trigger will be enabled if the XML file contains a node /packagedElement where the xmi:type property equals uml:Class.\n\n\n\n\n\n\nVariable Assignment types\n\nFurthermore, it provides the ability to extract information from each input for further processing in the templates. The values assigned by variable assignments will be made available in template and the destinationPath of context.xml through the namespace variables.&lt;key&gt;. The XML Plug-in currently provides only one mechanism:\n\n\n\n\ntype 'constant' → constant parameter\n\n\n\n\n\n\n\n\n\nThis variable assignment assigns the value to the key as a constant.\n\n\n\nXML input reader\n\nThe CobiGen XML Plug-in implements an input reader for parsed XML documents. So API user can pass org.w3c.dom.Document objects for generation. For getting the right parsed XML inputs you can easily use the xmlplugin.util.XmlUtil, which provides static functionality to parse XML files or input streams and get the appropriate Document object.\n\n\nTemplate object\n\nDue to the heterogeneous structure an XML document can have, the XML input reader does not always create exactly the same model structure (in contrast to the java input reader). For example the model’s depth differs strongly, according to it’s input document. To allow navigational access to the nodes, the model also depends on the document’s element’s node names. All child elements with unique names, are directly accessible via their names. In addition it is possible to iterate over all child elements with held of the child list Children. So it is also possible to access child elements with non unique names.\n\n\nThe XML input reader will create the following object model for template creation (EXAMPLEROOT, EXAMPLENODE1, EXAMPLENODE2, EXAMPLEATTR1,…​ are just used here as examples. Of course they will be replaced later by the actual node or attribute names):\n\n\n\n\n~EXAMPLEROOT~ ('Map&lt;String, Object&gt;' :: common element structure)\n\n\n\n_nodeName_ ('String' :: Simple name of the root node)\n\n\n_text_ ('String' :: Concatenated text content (PCDATA) of the root node)\n\n\nTextNodes ('List&lt;String&gt;' :: List of all the root’s text node contents)\n\n\n_at_~EXAMPLEATTR1~ ('String' :: String representation of the attribute’s value)\n\n\n_at_~EXAMPLEATTR2~ ('String' :: String representation of the attribute’s value)\n\n\n_at_…​\n\n\nAttributes ('List&lt;Map&lt;String, Object&gt;&gt;' :: List of the root’s attributes\n\n\n\nat ('Map&lt;String, Object&gt;' :: List element)\n\n\n\n_attName_ ('String' :: Name of the attribute)\n\n\n_attValue_ ('String' :: String representation of the attribute’s value)\n\n\n\n\n\n\n\n\nChildren ('List&lt;Map&lt;String, Object&gt;&gt;' :: List of the root’s child elements\n\n\n\nchild ('Map&lt;String, Object&gt;' :: List element)\n\n\n\n…​common element sub structure…​\n\n\n\n\n\n\n\n\n~EXAMPLENODE1~ ('Map&lt;String, Object&gt;' :: One of the root’s child nodes)\n\n\n\n…​common element structure…​\n\n\n\n\n\n~EXAMPLENODE2~ ('Map&lt;String, Object&gt;' :: One of the root’s child nodes)\n\n\n\n…​common element sub structure…​\n\n\n~EXAMPLENODE21~ ('Map&lt;String, Object&gt;' :: One of the nodes' child nodes)\n\n\n\n…​common element structure…​\n\n\n\n\n\n~EXAMPLENODE…​~\n\n\n\n\n\n~EXAMPLENODE…​~\n\n\n\n\n\n\n\nIn contrast to the java input reader, this XML input reader does currently not provide any additional template methods.\n\n\n\n\n\nMerger extensions\n\nThe XML plugin uses the LeXeMe merger library to produce semantically correct merge products. The merge strategies can be found in the MergeType enum and can be configured in the templates.xml as a mergeStrategy attribute:\n\n\n\n\nmergeStrategy xmlmerge\n\nListing 145. Example of a template using the mergeStrategy xmlmerge\n\n\n\n\n\n\n\n\nCurrently only the document types included in LeXeMe are supported.\nOn how the merger works consult the LeXeMe Wiki.\n\n\n\n\n\nText Merger Plug-in\n\nThe Text Merger Plug-in enables merging result free text documents to existing free text documents. Therefore, the algorithms are also very rudimentary.\n\n\nMerger extensions\n\nThere are currently three main merge strategies that apply for the whole document:\n\n\n\n\nmerge strategy textmerge_append (appends the text directly to the end of the existing document)\n_Remark_: If no anchors are defined, this will simply append the patch.\n\n\nmerge strategy textmerge_appendWithNewLine (appends the text after adding a new line break to the existing document)\n_Remark_: empty patches will not result in appending a new line any more since v1.0.1\nRemark: Only suitable if no anchors are defined, otherwise it will simply act as textmerge_append\n\n\nmerge strategy textmerge_override (replaces the contents of the existing file with the patch)\n_Remark_: If anchors are defined, override is set as the default mergestrategy for every text block if not redefined in an anchor specification.\n\n\n\n\n\nAnchor functionality\n\nIf a template contains text that fits the definition of anchor:${documentpart}:${mergestrategy}:anchorend or more specifically the regular expression (.*)anchor:([:]+):(newline_)?([:]+)(_newline)?:anchorend\\\\s*(\\\\r\\\\n|\\\\r|\\\\n), some additional functionality becomes available about specific parts of the incoming text and the way it will be merged with the existing text. These anchors always change things about the text to come up until the next anchor, text before it is ignored.\n\n\nIf no anchors are defined, the complete patch will be appended depending on your choice for the template in the file templates.xml.\n\n\nAnchor Definition\n\nAnchors should always be defined as a comment of the language the template results in, as you do not want them to appear in your readable version, but cannot define them as FreeMarker comments in the template, or the merger will not know about them.\nAnchors will also be read when they are not comments due to the merger being able to merge multiple types of text-based languages, thus making it practically impossible to filter for the correct comment declaration. That is why anchors have to always be followed by line breaks. That way there is a universal way to filter anchors that should have anchor functionality and ones that should appear in the text.\nRemark: If the resulting language has closing tags for comments, they have to appear in the next line.\nRemark: If you do not put the anchor into a new line, all the text that appears before it will be added to the anchor.\n\n\n\nDocument parts\n\nIn general, ${documentpart} is an id to mark a part of the document, that way the merger knows what parts of the text to merge with which parts of the patch (e.g. if the existing text contains anchor:table:${}:anchorend that part will be merged with the part tagged anchor:table:${}:anchorend of the patch).\n\n\nIf the same documentpart is defined multiple times, it can lead to errors, so instead of defining table multiple times, use table1, table2, table3 etc.\n\n\nIf a ${documentpart} is defined in the document but not in the patch and they are in the same position, it is processed in the following way: If only the documentparts header, test and footer are defined in the document in that order, and the patch contains header, order and footer, the resulting order will be header, test, order then footer.\n\n\nThe following documentparts have default functionality:\n\n\n\n\nanchor:header:${mergestrategy}:anchorend marks the beginning of a header, that will be added once when the document is created, but not again.\nRemark: This is only done once, if you have header in another anchor, it will be ignored\n\n\nanchor:footer:${mergestrategy}:anchorend marks the beginning of a footer, that will be added once when the document is created, but not again. Once this is invoked, all following text will be included in the footer, including other anchors.\n\n\n\n\n\nMergestrategies\n\nMergestrategies are only relevant in the patch, as the merger is only interested in how text in the patch should be managed, not how it was managed in the past.\n\n\n\n\nanchor:${documentpart}::anchorend will use the merge strategy from templates.xml, see Merger-Extensions.\n\n\nanchor:${}:${mergestrategy}_newline:anchorend or anchor:${}:newline_${mergestrategy}:anchorend states that a new line should be appended before or after this anchors text, depending on where the newline is (before or after the mergestrategy). anchor:${documentpart}:newline:anchorend puts a new line after the anchors text.\nRemark: Only works with appending strategies, not merging/replacing ones. These strategies currently include: appendbefore, append/appendafter\n\n\nanchor:${documentpart}:override:anchorend means that the new text of this documentpart will replace the existing one completely\n\n\nanchor:${documentpart}:appendbefore:anchorend or anchor:${documentpart}:appendafter:anchorend/anchor:${documentpart}:append:anchorend specifies whether the text of the patch should come before the existing text or after.\n\n\n\n\n\n\nUsage Examples\n\nGeneral\n\nBelow you can see how a file with anchors might look like (using Asciidoc comment tags), with examples of what you might want to use the different functions for.\n\n\n\n\n\n\n\n\nMerging\n\nIn this section you will see a comparison on what files look like before and after merging\n\n\noverride\n\nListing 146. Before\n\n\n\n\n\nListing 147. Patch\n\n\n\n\n\nListing 148. After\n\n\n\n\n\n\nAppending\n\nListing 149. Before\n\n\n\n\n\nListing 150. Patch\n\n\n\n\n\nListing 151. After\n\n\n\n\n\n\nNewline\n\nListing 152. Before\n\n\n\n\n\nListing 153. Patch\n\n\n\n\n\nListing 154. After\n\n\n\n\n\n\n\n\nError List\n\n\n\nIf there are anchors in the text, but either base or patch do not start with one, the merging process will be aborted, as text might go missing this way.\n\n\nUsing _newline or newline_ with mergestrategies that don’t support it , like override, will abort the merging process. See &lt;&lt;`mergestrategies`,Merge Strategies&gt;&gt; →2 for details.\n\n\nUsing undefined mergestrategies will abort the merging process.\n\n\nWrong anchor definitions, for example anchor:${}:anchorend will abort the merging process, see &lt;&lt;`anchordef`,Anchor Definition&gt;&gt; for details.\n\n\n\n\n\n\n\nJSON Plug-in\n\nAt the moment the plug-in can be used for merge generic JSON files depending on the merge strategy defined at the templates.\n\n\nMerger extensions\n\nThere are currently these merge strategies:\n\n\nGeneric JSON Merge\n\n\n\n\nmerge strategy jsonmerge(add the new code respecting the existent is case of conflict)\n\n\nmerge strategy jsonmerge_override (add the new code overwriting the existent in case of conflict)\n\n\n\nJsonArray’s will be ignored / replaced in total\n\n\nJsonObjects in conflict will be processed recursively ignoring adding non existent elements.\n\n\n\n\n\n\n\n\nMerge Process\n\nGeneric JSON Merging\n\nThe merge process will be:\n\n\n\n\nAdd non existent JSON Objects from patch file to base file.\n\n\nFor existent object in both files, will add non existent keys from patch to base object. This process will be done recursively for all existent objects.\n\n\nFor JSON Arrays existent in both files, the arrays will be just concatenated.\n\n\n\n\n\n\n\n\nTypeScript Plug-in\n\nThe TypeScript Plug-in enables merging result TS files to existing ones. This plug-in is used at the moment for generate an Angular2 client with all CRUD functionalities enabled. The plug-in also generates i18n functionality just appending at the end of the word the ES or EN suffixes, to put into the developer knowledge that this words must been translated to the correspondent language. Currently, the generation of Angular2 client requires an ETO java object as input so, there is no need to implement an input reader for ts artifacts for the moment.\n\n\nTrigger Extensions\n\nAs for the Angular2 generation the input is a java object, the trigger expressions (including matchers and variable assignments) are implemented as Java.\n\n\n\nMerger extensions\n\nThis plugin uses the TypeScript Merger to merge files. There are currently two merge strategies:\n\n\n\n\nmerge strategy tsmerge (add the new code respecting the existing is case of conflict)\n\n\nmerge strategy tsmerge_override (add the new code overwriting the existent in case of conflict)\n\n\n\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nThe merge algorithm mainly handles the following AST nodes:\n\n\n\n\nImportDeclaration\n\n\n\nWill add non existent imports whatever the merge strategy is.\n\n\nFor different imports from same module, the import clauses will be merged.\n\n\n\n\n\n\n\n\n\n\nClassDeclaration\n\n\n\nAdds non existent base properties from patch based on the name property.\n\n\nAdds non existent base methods from patch based on the name signature.\n\n\nAdds non existent annotations to class, properties and methods.\n\n\n\n\n\nPropertyDeclaration\n\n\n\nAdds non existent decorators.\n\n\nMerge existent decorators.\n\n\nWith override strategy, the value of the property will be replaced by the patch value.\n\n\n\n\n\nMethodDeclaration\n\n\n\nWith override strategy, the body will be replaced.\n\n\nThe parameters will be merged.\n\n\n\n\n\nParameterDeclaration\n\n\n\nReplace type and modifiers with override merge strategy, adding non existent from patch into base.\n\n\n\n\n\nConstructorDeclaration\n\n\n\nMerged in the same way as Method is.\n\n\n\n\n\nFunctionDeclaration\n\n\n\nMerged in the same way as Method is.\n\n\n\n\n\n\n\n\nInput reader\n\nThe TypeScript input reader is based on the one that the TypeScript merger uses. The current extensions are additional module fields giving from which library any entity originates.\nmodule: null specifies a standard entity or type as string or number.\n\n\nObject model\n\nTo get a first impression of the created object after parsing, let us start with analyzing a small example, namely the parsing of a simple type-orm model written in TypeScript.\n\n\n\n\n\n\n\nThe returned object has the following structure\n\n\n\n\n\n\n\nIf we only consider the first level of the JSON response, we spot two lists of imports and classes, providing information about the only import statement and the only User class, respectively. Moving one level deeper we observe that:\n\n\n\n\nEvery import statement is translated to an import declaration entry in the declarations list, containing the module name, as well as a list of entities imported from the given module.\n\n\nEvery class entry provides besides the class identifier, its decoration(s), modifier(s), as well as a list of properties that the original class contains.\n\n\n\n\nNote that, for each given type, the module from which it is imported is also given as in\n\n\n\n\n\n\n\nReturning to the general case, independently from the given TypeScript file, an object having the following Structure will be created.\n\n\n\n\nimportDeclarations: A list of import statement as described above\n\n\nexportDeclarations: A list of export declarations\n\n\nclasses: A list of classes extracted from the given file, where each entry is full of class specific fields, describing its properties and decorator for example.\n\n\ninterfaces: A list of interfaces.\n\n\nvariables: A list of variables.\n\n\nfunctions: A list of functions.\n\n\nenums: A list of enumerations.\n\n\n\n\n\n\n\n\nHTML Plug-in\n\nThe HTML Plug-in enables merging result HTML files to existing ones. This plug-in is used at the moment for generate an Angular2 client. Currently, the generation of Angular2 client requires an ETO java object as input so, there is no need to implement an input reader for ts artifacts for the moment.\n\n\nTrigger Extensions\n\nAs for the Angular2 generation the input is a java object, the trigger expressions (including matchers and variable assignments) are implemented as Java.\n\n\n\nMerger extensions\n\nThere are currently two merge strategies:\n\n\n\n\nmerge strategy html-ng* (add the new code respecting the existing is case of conflict)\n\n\nmerge strategy html-ng*_override (add the new code overwriting the existent in case of conflict)\n\n\n\n\nThe merging of two Angular2 files will be processed as follows:\n\n\nThe merge algorithm handles the following AST nodes:\n\n\n\n\nmd-nav-list\n\n\na\n\n\nform\n\n\nmd-input-container\n\n\ninput\n\n\nname (for name attribute)\n\n\nngIf\n\n\n\n\n\n\n\n\n\n\nBe aware, that the HTML merger is not generic and only handles the described tags needed for merging code of a basic Angular client implementation. For future versions, it is planned to implement a more generic solution.\n\n\n\n\n\n\n\n\nOpenAPI Plug-in\n\nThe OpenAPI Plug-in enables the support for Swagger files that follows the OpenAPI 3.0 standard as input for CobiGen. Until now, CobiGen was thought to follow a \"code first\" generation, with this plugin, now it can also follow the \"contract first\" strategy\n\n\n\n\nCode First\n\n\n\nGenerating from a file with code (Java/XML code in our case)\n\n\n\n\n\nContract First\n\n\n\nGeneration from a full definition file (Swagger in this case). This file contains all the information about entities, operations, etc…​\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf you are not a CobiGen developer, you will be more interested in usage.\n\n\n\n\n\nTrigger Extensions\n\nThe OpenAPI Plug-in provides a new trigger for Swagger OpenAPI 3.0 related inputs. It accepts different representations as inputs (see OpenAPI input reader) and provides additional matching and variable assignment mechanisms. The configuration in the context.xml for this trigger looks like this:\n\n\n\n\ntype openapi\n\nListing 155. Example of a OpenAPI trigger definition\n\n\n\n\n\nThis trigger type enables OpenAPI elements as inputs.\n\n\n\n\n\nMatcher type\n\nWith the trigger you might define matchers, which restrict the input upon specific aspects:\n\n\n\n\ntype 'element' → An object\n\n\n\n\nThis trigger will be enabled if the element (Java Object) of the input file is and EntityDef (value).\n\n\n\nContainer Matcher type\n\nAdditionally, the java plugin provides the ability to match packages (containers) as follows:\n\n\n\n\ntype 'element'\n\n\n\n\nThe container matcher matches elements as Java Objects, in this case will be always an OpenAPIFile object. (See containerMatcher semantics to get more information about containerMatchers itself.)\n\n\n\nVariable Assignment types\n\nFurthermore, it provides the ability to extract information from each input for further processing in the templates. The values assigned by variable assignments will be made available in template and the destinationPath of context.xml through the namespace variables.&lt;key&gt;. The OpenAPI Plug-in currently provides two different mechanisms:\n\n\n\n\ntype 'constant' → constant parameter\n\n\n\n\n\n\n\n\n\nThis variable assignment assigns the value of the given regular expression group number to the given key.\nIn this case, the constant type variableAssignment is used to specify the root package where the generate will place the files generated.\n\n\n\n\ntype 'extension' → Extraction of the info extensions and the extensions of each entity. (the tags that start with \"x-…​\").\n\n\n\n\n\n\n\n\n\nThe 'extension' variable assignment tries to find 'extensions' (tags that start with \"x-…​\") on the 'info'\npart of your file and on the extensions of each entity. value is the extension that our plug-in will try to find on your OpenAPI file. The result will\nbe stored in the variable key.\n\n\nAs you will see on the figure below, there are two types of variables: The global ones, that are defined\non the 'info' part of the file, and the local ones, that are defined inside each entity.\n\n\nTherefore, if you want to define the root package, then you will have to declare it on the 'info' part.\nThat way, all your entities will be generated under the same root package (e.g. com.devonfw.project).\n\n\n\n\n\nIf no extension with that name was found, then an empty string will be assigned. In the case of not defining the root package, then the code will be generated into src/main/java.\n\n\n\n\ntype 'property' → property of the Java Object\n\n\n\n\n\n\n\n\n\nThe 'property' variable assignment tries to find the property value of the entities defined on the schema.\nThe value is assigned to the key. The current properties that you will able to get are:\n\n\n\n\nComponentDef component: It is an object that stores the configuration of an devon4j component. Its only\nproperty is List&lt;PathDef&gt; paths which contains the paths as the ones shown here.\n\n\nString componentName: Stores the name of the x-component tag for this entity.\n\n\nString name: Name of this entity (as shown on the example above).\n\n\nString description: Description of this entity.\n\n\nList&lt;PropertyDef&gt; properties: List containing all the properties of this entity. PropertyDef is an object that has the next properties:\n\n\n\nString name.\n\n\nString type.\n\n\nString format.\n\n\nString description.\n\n\nBoolean isCollection.\n\n\nBoolean isEntity.\n\n\nBoolean required.\n\n\nMap&lt;String, Object&gt; constraints\n\n\n\n\n\n\n\nIf no property with that name was found, then it will be set to null.\n\n\n\nFull trigger configuration\n\n\n\n\n\n\n\n\nInput reader\n\nThe CobiGen OpenAPI Plug-in implements an input reader for OpenAPI 3.0 files. The XML input reader will create the following object model for template creation:\n\n\n\n\nmodel ('Map&lt;String, Object&gt;' :: common element structure)\n\n\n\nheader (HeaderDef :: Definition of the header found at the top of the file)\n\n\nname ('String' :: Name of the current Entity)\n\n\ncomponentName ('String' :: name of the component the entity belongs to)\n\n\ncomponent (ComponentDef :: Full definition of the component that entity belongs to)\n\n\ndescription ('String' :: Description of the Entity)\n\n\nproperties (List&lt;PropertyDef&gt; :: List of properties the entity has)\n\n\nrelationShips (List&lt;RelationShip&gt; :: List of Relationships the entity has)\n\n\n\n\n\nHeaderDef ('Map&lt;String, Object&gt;' :: common element structure)\n\n\n\ninfo (InfoDef :: Definition of the info found in the header)\n\n\nservers (List&lt;ServerDef&gt; :: List of servers the specification uses)\n\n\n\n\n\nInfoDef ('Map&lt;String, Object&gt;' :: common element structure)\n\n\n\ntitle ('String' :: The title of the specification)\n\n\ndescription ('String' :: The description of the specification)\n\n\n\n\n\nServerDef ('Map&lt;String, Object&gt;' :: common element structure)\n\n\n\nURI ('String' :: String representation of the Server location)\n\n\ndescription ('String' :: description of the server)\n\n\n\n\n\nComponentDef ('Map&lt;String, Object&gt;' :: common element structure)\n\n\n\npaths (List&lt;PathDef&gt; :: List of services for this component)\n\n\n\n\n\nPropertyDef ('Map&lt;String, Object&gt;' :: common element structure)\n\n\n\nname ('String' :: Name of the property)\n\n\ntype ('String' :: type of the property)\n\n\nformat ('String' :: format of the property (i.e. int64))\n\n\nisCollection (boolean :: true if the property is a collection, false by default)\n\n\nisEntity (boolean :: true if the property refers to another entity, false by default)\n\n\nsameComponent (boolean :: true if the entity that the property refers to belongs to the same component, false by default)\n\n\ndescription ('String' :: Description of the property)\n\n\nrequired (boolean :: true if the property is set as required)\n\n\nconstraints ('Map&lt;String, Object&gt;')\n\n\n\n\n\nRelationShip ('Map&lt;String, Object&gt;' :: common element structure)\n\n\n\ntype ('String' :: type of the relationship (OneToOne, ManyToMany, etc…​))\n\n\nentity ('String' :: destination entity name)\n\n\nsameComponent (boolean :: true if the destination entity belongs to the same component of the source entity, false by default)\n\n\nunidirectional (boolean :: true if the relationship is unidirectional, false by default)\n\n\n\n\n\nPathDef ('Map&lt;String, Object&gt;' :: common element structure)\n\n\n\nrootComponent ('String' :: the first segment of the path)\n\n\nversion ('String' :: version of the service)\n\n\npathURI ('String' :: URI of the path, the segment after the version)\n\n\noperations (List&lt;OperationDef&gt; :: List of operations for this path)\n\n\n\n\n\nOperationDef ('Map&lt;String, Object&gt;' :: common element structure)\n\n\n\ntype ('String' :: type of the operation (GET, PUT, etc…​))\n\n\nparameters (List&lt;ParameterDef&gt; :: List of parameters)\n\n\noperationId ('String' :: name of the operation prototype)\n\n\ndescription ('String' :: JavaDoc Description of the operation)\n\n\nsummary (List&lt;PropertyDef&gt; :: JavaDoc operation Summary)\n\n\ntags ('List&lt;String&gt;' :: List of different tags)\n\n\nresponses (List&lt;ResponseDef&gt; :: Responses of the operation)\n\n\n\n\n\nParameterDef ('Map&lt;String, Object&gt;' :: common element structure)\n\n\n\nisSearchCriteria (boolean :: true if the response is an SearchCriteria object)\n\n\ninPath (boolean :: true if this parameter is contained in the request path)\n\n\ninQuery (boolean :: true if this parameter is contained in a query)\n\n\nisBody (boolean :: true if this parameter is a response body)\n\n\ninHeader (boolean :: true if this parameter is contained in a header)\n\n\nmediaType ('String' :: String representation of the media type of the parameter)\n\n\n\n\n\nResponseDef ('Map&lt;String, Object&gt;' :: common element structure)\n\n\n\nisArray (boolean :: true if the type of the response is an Array)\n\n\nisPaginated (boolean :: true if the type of the response is paginated)\n\n\nisVoid (boolean :: true if there is no type/an empty type)\n\n\nisEntity (boolean :: true if the type of the response is an Entity)\n\n\nentityRef (EntityDef :: Incomplete EntityDef containing the name and properties of the referenced Entity)\n\n\ntype ('String' :: String representation of the attribute’s value)\n\n\ncode ('String' :: String representation of the HTTP status code)\n\n\nmediaTypes ('List&lt;String&gt;' :: List of media types that can be returned)\n\n\ndescription ('String' :: Description of the response)\n\n\n\n\n\n\n\n\nMerger extensions\n\nThis plugin only provides an input reader, there is no support for OpenAPI merging. Nevertheless, the files generated from an OpenAPI file will be Java, XML, JSON, TS, etc…​ so,\nfor each file to be generated defined at templates.xml, must set the mergeStrategy for the specific language (javamerge, javamerge_override, jsonmerge, etc…​)\n\n\n\n\n\n\n\n\nUsage\n\nWriting OpenAPI 3.0 contract file\n\nThe Swagger file must follow the OpenAPI 3.0 standard to be readable by CobiGen, otherwise and error will be thrown.\nA full documentation about how to follow this standard can be found Swagger3 Docs.\n\n\nThe Swagger file must be at the core folder of your devon4j project, like shown below:\n\n\n\n\n\nTo be compatible with CobiGen and devon4j, it must follow some specific configurations. This configurations allows us to avoid redundant definitions as SearchCriteria and PaginatedList objects are used at the services definitions.\n\n\n\nPaths\n\n\n\nJust adding the tags property at the end of the service definitions with the items `SearchCriteria` and/or paginated put into CobiGen knowledge that an standard devon4j SearchCriteria and/or PaginateListTo object must be generated. That way, the Swagger file will be easier to write and even more understandable.\n\n\nThe path must start with the component name, and define an x-component tag with the component name. That way this service will be included into the component services list.\n\n\n\n\n\n\n\n\n\nThat way, CobiGen will be able to generate the endpoint (REST service) customOperation on componentmanagement. If you do not specify the component to generate to (the x-component tag) then this service will not be taken into account for generation.\n\n\n\nService based generation\n\nIn previous CobiGen versions, we were able to generate code from a contract-first OpenAPI specification only when we defined components like the following:\n\n\n\n\n\n\n\nWe could not generate services without the definition of those components.\n\n\nIn our current version, we have overcome it, so that now we are able to generate all the services independently. You just need to add an x-component tag with the name of the component that will make use of that service. See here.\n\n\nAn small OpenAPI example defining only services can be found below:\n\n\n\n\n\n\n\nThen, the increment that you need to select for generating those services is Crud devon4ng Service based Angular:\n\n\n\n\n\n\nFull example\n\nThis example yaml file can be download from here.\n\n\n\n\n\n\n\n\nAs you will see on the file, \"x-component\" tags are obligatory if you want to generate components (entities). They have to be defined for each one.\nIn addition, you will find the global variable \"x-rootpackage\" that are explained &lt;&lt;,here&gt;&gt;.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}