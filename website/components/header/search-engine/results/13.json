{"type":"doc","filename":"asciidoc_devonfw-guide_devon4j.wiki_devon4j.asciidoc_guides.html","anchor":"devonfw-guide_devon4j.wiki_guide-datatype.asciidoc","title":"Datatypes","breadcrumbs":["Java","Spring","Guides"],"text":"Datatypes\n\n\n\nA datatype is an object representing a value of a specific type with the following aspects:\n\n\n\n\nIt has a technical or business specific semantic.\n\n\nIts JavaDoc explains the meaning and semantic of the value.\n\n\nIt is immutable and therefore stateless (its value assigned at construction time and can not be modified).\n\n\nIt is serializable.\n\n\nIt properly implements #equals(Object) and #hashCode() (two different instances with the same value are equal and have the same hash).\n\n\nIt shall ensure syntactical validation so it is NOT possible to create an instance with an invalid value.\n\n\nIt is responsible for formatting its value to a string representation suitable for sinks such as UI, loggers, etc. Also consider cases like a Datatype representing a password where toString() should return something like \"**\" instead of the actual password to prevent security accidents.\n\n\nIt is responsible for parsing the value from other representations such as a string (as needed).\n\n\nIt shall provide required logical operations on the value to prevent redundancies. Due to the immutable attribute all manipulative operations have to return a new Datatype instance (see e.g. BigDecimal.add(java.math.BigDecimal)).\n\n\nIt should implement Comparable if a natural order is defined.\n\n\n\n\nBased on the Datatype a presentation layer can decide how to view and how to edit the value. Therefore a structured data model should make use of custom datatypes in order to be expressive.\nCommon generic datatypes are String, Boolean, Number and its subclasses, Currency, etc.\nPlease note that both Date and Calendar are mutable and have very confusing APIs. Therefore, use JSR-310 or jodatime instead.\nEven if a datatype is technically nothing but a String or a Number but logically something special it is worth to define it as a dedicated datatype class already for the purpose of having a central javadoc to explain it. On the other side avoid to introduce technical datatypes like String32 for a String with a maximum length of 32 characters as this is not adding value in the sense of a real Datatype.\nIt is suitable and in most cases also recommended to use the class implementing the datatype as API omitting a dedicated interface.\n\n\n\n— mmm project\ndatatype javadoc\n\n\n\nSee mmm datatype javadoc.\n\n\nDatatype Packaging\n\nFor the devonfw we use a common packaging schema.\nThe specifics for datatypes are as following:\n\n\n\n\n\n\n\n\n\nSegment\nValue\nExplanation\n\n\n\n\n&lt;component&gt;\n*\nHere we use the (business) component defining the datatype or general for generic datatypes.\n\n\n&lt;layer&gt;\ncommon\nDatatypes are used across all layers and are not assigned to a dedicated layer.\n\n\n&lt;scope&gt;\napi\nDatatypes are always used directly as API even tough they may contain (simple) implementation logic. Most datatypes are simple wrappers for generic Java types (e.g. String) but make these explicit and might add some validation.\n\n\n\n\n\nTechnical Concerns\n\nMany technologies like Dozer and QueryDSL’s (alias API) are heavily based on reflection. For them to work properly with custom datatypes, the frameworks must be able to instantiate custom datatypes with no-argument constructors. It is therefore recommended to implement a no-argument constructor for each datatype of at least protected visibility.\n\n\n\nDatatypes in Entities\n\nThe usage of custom datatypes in entities is explained in the persistence layer guide.\n\n\n\nDatatypes in Transfer-Objects\n\nXML\n\nFor mapping datatypes with JAXB see XML guide.\n\n\n\nJSON\n\nFor mapping datatypes from and to JSON see JSON custom mapping.\n\n\n\n\n\n\n\n"}