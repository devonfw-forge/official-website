{"type":"doc","filename":"devonfw-guide_devon4j.wiki_guide-dependency-injection.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_guide-dependency-injection.asciidoc_key-principles","title":"Key Principles","breadcrumbs":["Java","General","Dependency Injection"],"text":"Key Principles\n\nWithin dependency injection a bean is typically a reusable unit of your application providing an encapsulated functionality.\nThis bean can be injected into other beans and it should in general be replaceable.\nAs an example we can think of a use-case, a repository, etc.\nAs best practice we use the following principles:\n\n\n\n\nStateless implementation\nBy default such beans shall be implemented stateless. If you store state information in member variables you can easily run into concurrency problems and nasty bugs. This is easy to avoid by using local variables and separate state classes for complex state-information. Try to avoid stateful beans wherever possible. Only add state if you are fully aware of what you are doing and properly document this as a warning in your JavaDoc.\n\n\nUsage of Java standards\nWe use common standards (see above) that makes our code portable. Therefore we use standardized annotations like @Inject (javax.inject.Inject) instead of proprietary annotations such as @Autowired. Generally we avoid proprietary annotations in business code (logic layer).\n\n\nSimple injection-style\nIn general you can choose between constructor, setter or field injection. For simplicity we recommend to do private field injection as it is very compact and easy to maintain. We believe that constructor injection is bad for maintenance especially in case of inheritance (if you change the dependencies you need to refactor all sub-classes). Private field injection and public setter injection are very similar but setter injection is much more verbose (often you are even forced to have javadoc for all public methods). If you are writing re-usable library code setter injection will make sense as it is more flexible. In a business application you typically do not need that and can save a lot of boiler-plate code if you use private field injection instead. Nowadays you are using container infrastructure also for your tests (see testing) so there is no need to inject manually (what would require a public setter).\n\n\nKISS\nTo follow the KISS (keep it small and simple) principle we avoid advanced features (e.g. custom AOP, non-singleton beans) and only use them where necessary.\n\n\nSeparation of API and implementation\nFor important components we should separate a self-contained API documented with JavaDoc from its implementation. Code from other components that wants to use the implementation shall only rely on the API. However, for things that will never be exchanged no API as interface is required you can skip such separation.\n\n\n\n\n\n"}