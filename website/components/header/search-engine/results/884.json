{"type":"solution","filename":"communication/index.asciidoc","title":"Communication","breadcrumbs":[],"text":"//Category=Communication\n//Product=Kafka; Istio\n//Maturity level=Complete\n\n= Communication\n\n== Communication among services\nCommunication is a very important aspect while building IT application, especially large and complex one or one with microservices architecture. Based on your analysis of your problems, considering the following basic questions to start with:\n\n* Which services have to communicate with which services? to exchange which type of data?\n* How should the communication look like? in a synchronous way or asynchronous way?\n\nOnce you have your answers, make your choices on concrete protocols, products and libraries. Using multiple of them in your application is fine.\n\nUnfortunately, there is no silver bullet. Each communication type has its own advantages and disadvantages and target a different scenario and goals. With that said, do not always apply REST or always apply message-driven approaches (e.g. Kafka) just because you have heard some success stories about it.\n\nHere we try to expose cross-cutting best practices for communication among services in larger IT application landscapes on a high level. Details how to implement this with specific libraries or programming-languages are described in the individual stacks of devonfw.\n\n== Communication types\nGenerally, types of communication can be classified in two axes.\n\nimage::communication-type.svg[Communication types]\n\nThe first axis defines if the protocol is synchronous or asynchronous:\n\n    * *Synchronous protocol*: The client sends a request and waits for a response from the service as the client code can only continue its task when it receives the server response. That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually). e.g. HTTP/HTTPs\n    * *Asynchronous protocol*: The client code or message sender usually doesn't wait for a response. It just sends the message as when sending a message to a queue or any other message broker. e.g AMQP\n\nThe second axis defines if the communication has a single receiver or multiple receivers:\n\n    * *Single receiver*: Each request must be processed by exactly one receiver or service.\n    * *Multiple receivers*: Each request can be processed by zero to multiple receivers. This type of communication must be asynchronous. An example is the publish/subscribe mechanism.\n\nOne common style is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service. Microservices also typically use messaging protocols for asynchronous communication between microservices. We will discuss more about some popular approaches adopted these days including:\n\n    * <<rpc>>\n    * <<messaging_and_eventing>>\n    * <<service_mesh>>\n\n[#rpc]\n=== RPC\nWhen it comes to RPC communication nowadays we immediately talk about HTTPS.\n\nThe most common choice is https://en.wikipedia.org/wiki/Representational_state_transfer[REST] with https://www.json.org/[JSON] that perfectly works together with web browsers.\nHowever, please also consider other options especially for backend communication:\n\n* https://grpc.io/[gRPC] is an efficient, high performance RPC protocol\n* ...\n\nProtocols like https://en.wikipedia.org/wiki/SOAP[SOAP] or even RMI, Corba, etc. should be considered as legacy and discouraged.\n\n[#messaging_and_eventing]\n=== Messaging and eventing\n\nWe do not even try to distinguish between _messaging_ and _eventing_.\nA message can be seen as an event and an event as a message.\nThe nature of this communication style is that it is entirely asynchronous and the sender of the event or message does not have to know about the receipient(s).\nThere can even be many recipients for the same event or message.\nTypically there is a central messaging system (event bus) that is all you need to know about to send and receive your events or messages.\nThis leads to a very loose coupling of your services.\nWhile this adds flexibility it also can add quite some complexity to understand what is actually going on.\nDebugging and tracing the communication can get really hard.\nIn the worst case you can lose control and end up with cyclic events triggering each other till eternity.\nHowever, when properly applied, this communication style can make your architecture very powerful and extendable.\n\nOne of the most common choices for such a messaging system is https://kafka.apache.org[kafka]. Other message brokers to be considered are https://www.rabbitmq.com/[RabbitMQ] and https://activemq.apache.org/[ActiveMQ]. In an enterprise environment where often a Oracle Database is in place you might also consider Oracle AQ.\n\n[#service_mesh]\n=== Service mesh\nIn the context of microservices, service mesh is a key to communication.\nService-to-service communication is what makes microservices possible.\nBut creating, routing and managing this communication, both within and across application clusters, becomes increasingly complex as the number of services grows.\nService mesh solves this problem. It takes the logic governing service-to-service communication out of individual services and abstracts it to a layer of infrastructure.\nIt also captures many aspects of the communication as security (e.g. encryption) or performance metrics which can be used to monitor the cluster as well as identify and analyze system failures if occurs.\n\nOne of the most common and best choices for service mesh is https://istio.io/latest/about/service-mesh/[istio].\nIstio is an open-source service mesh with powerful features that enable developers to easily configure\n\n    1. the traffic flow\n\n    2. the authentication and authorization among internal and to external services and\n\n    3. monitoring tools such as kiali, prometheus and grafana.\n\n== Communication contracts\n\nA communication contract is a structured document that defines the expected input and output of a service.\n\nThere are two approaches to using contracts for communications:\n\n- *Contract first*: There is a design document that defines the formal contract of the communication and the code artefacts are derived with some tooling.\n- *Code first*: Code is written directly and documentation is generated from there.\n\nWhich approach is better depends on your project setup.\nWhile code first often feels more lightweight and brings less over head, for a more complex project setup the formality of the contract could be very beneficial.\n\nContracts can be used both for synchronous or asynchronous communications, for example https://www.openapis.org/[Open Api] has become the standard for REST contracts and https://www.asyncapi.com/[Async Api] is growing in adoption for the asynchronous needs.\n\n== Links\n\n* https://solace.com/blog/experience-awesomeness-event-driven-microservices/[REST vs messaging for microservices]\n* https://github.com/knative/eventing/blob/master/docs/decisions/eventing-and-messaging.md[Eventing and messaging]\n* https://developer.okta.com/blog/2020/01/22/kafka-microservices[Kafka microservices]\n* https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/communication-in-microservice-architecture[Communication in a microservices architecture]\n* https://istio.io/latest/docs/setup/getting-started/[Getting started with istio]\n* https://www.keycloak.org/2018/02/keycloak-and-istio.html[Keycloak and istio]\n\n== Implementation hints\n\n* REST:\n** https://github.com/devonfw/devon4j/blob/master/documentation/guide-rest.asciidoc[Java Server]\n** https://github.com/devonfw/devon4j/blob/master/documentation/guide-service-client.asciidoc[Java Client]\n** https://github.com/devonfw/devon4ng/blob/develop/documentation/guide-consuming-rest-services.asciidoc[Angular]\n** https://github.com/devonfw/devon4net/blob/develop/documentation/userguide.asciidoc#repositories-and-services[.NET/C#]\n** https://github.com/devonfw/devon4node/blob/develop/documentation/guides-swagger.asciidoc[node.js]\n* Kafka:\n** https://github.com/devonfw/devon4j/blob/master/documentation/guide-kafka.asciidoc[Java]\n"}