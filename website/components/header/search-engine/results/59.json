{"type":"doc","filename":"devonfw-guide_cobigen.wiki_master-cobigen.asciidoc_how-to.html","anchor":"devonfw-guide_cobigen.wiki_howto_create-a-new-plugin.asciidoc","title":"Implementing a new Plug-in","breadcrumbs":["Tools","CobiGen — Code-based incremental Generator","How to"],"text":"Implementing a new Plug-in\n\nNew plug-ins can implement an input reader, a merger, a matcher, a trigger interpreter, and/or a template engine as explained here.\n\n\n\n\n\n\n\n\n\nIt is discouraged to have cobigen-core dependencies at runtime, except for cobigen-core-api which definitely must be present.\n\n\n\n\n\n\nPlugin Activator\n\nEach plug-in has to have an plug-in activator class implementing the interface GeneratorPluginActivator from the core-api. This class will be used to load the plug-in using the PluginRegistry as explained here. This class implements two methods:\n\n\n\n\nbindMerger() → returns a mapping of merge strategies and its implementation to be registered.\n\n\nbindTriggerInterpreter()→ returns the trigger interpreters to be provided by this plug-in.\n\n\n\n\nBoth methods create and register instances of mergers and trigger interpreters to be provided by the new plug-in.\n\n\n\nAdding Trigger Interpreter\n\nThe trigger interpreter has to implement the TriggerInterpreter interface from the core. The trigger interpreter defines the type for the new plugin and creates new InputReader and new Matcher objects.\n\n\n\nAdding Input Reader\n\nThe input reader is responsible of read the input object and parse it into\n FreeMarker models. The input reader must be implemented for the type of the\n input file. If there is any existent plugin that has the same file type as input,\n there will be no need to add a new input reader to the new plug-in.\n\n\nInput Reader Interface\n\nThe interface needed to add a new input reader is defined at the core. Each new\nsub plug-in must implements this interface if is needed an input reader for it.\n\n\nThe interface implements the basic methods that an input reader must have,\nbut if additional methods are required, the developer must add a new interface\nthat extends the original interface `InputReader.java` from the core-api\nand implement that on the sub plug-in.\n\n\nThe methods to be implemented by the input reader of the new sub plugin are:\n\n\n\n\n\n\n\n\n\nMethod\nReturn Type\nDescription\n\n\n\n\nisValidInput(Object input)\nboolean\nThis function will be called if matching triggers or matching templates should be retrieved for a given input object.\n\n\ncreateModel(Object input)\nMap&lt;String, Object&gt;\nThis function should create the FreeMarker object model from the given input.\n\n\ncombinesMultipleInputObjects(Object input)\nboolean\nStates whether the given input object combines multiple input objects to be used for generation.\n\n\ngetInputObjects(Object input, Charset inputCharset)\nList&lt;Object&gt;\nWill return the set of combined input objects if the given input combines multiple input objects.\n\n\ngetTemplateMethods(Object input)\nMap&lt;String, Object&gt;\nThis method returns available template methods from the plugins as Map. If the plugin which corresponds to the input does not provide any template methods an empty Map will be returned.\n\n\ngetInputObjectsRecursively(Object input, Charset inputCharset)\nList&lt;Object&gt;\nWill return the set of combined input objects if the given input combines multiple input objects.\n\n\n\n\n\nModel Constants\n\nThe Input reader will create a model for FreeMarker. A FreeMarker model must\nhave variables to use them at the .ftl template file. Refer to Java Model to see the FreeMarker model example for java input files.\n\n\n\nRegistering the Input Reader\n\nThe input reader is an object that can be retrieved using the correspondent get\n method of the trigger interpreter object. The trigger interpreter object is\n loaded at the eclipse plug-in using the load plug-in method explained\n here.\n That way, when the core needs the input reader, only needs to call that getInputReader method.\n\n\n\n\nAdding Matcher\n\nThe matcher implements the MatcherInterpreter interface from the core-api.\nShould be implemented for providing a new input matcher. Input matcher are\ndefined as part of a trigger and provide the ability to restrict specific\ninputs to a set of templates.\nThis restriction is implemented with a MatcherType enum.\n\n\nE.g JavaPlugin\n\n\n\n\n\n\n\nFurthermore, matchers may provide several variable assignments, which might be\ndependent on any information of the matched input and thus should be resolvable\nby the defined matcher.\n\n\nE.g JavaPlugin\n\n\n\n\n\n\n\n\nAdding Merger\n\nThe merger is responsible to perform merge action between new output with the\nexistent data at the file if it already exists. Must implement the Merger\ninterface from the core-api.\nThe implementation of the Merge interface must override the following methods:\n\n\n\n\n\n\n\n\n\nMethod\nReturn Type\nDescription\n\n\n\n\ngetType()\nString\nReturns the type, this merger should handle.\n\n\nmerge(File base, String patch, String targetCharset)\nString\nMerges the patch into the base file.\n\n\n\n\nIs important to know that any exception caused by the merger must throw a MergeException from the core-api to the eclipse-plugin handle it.\n\n\n\nChanges since Eclipse / Maven 3.x\n\nSince version 3.x the Eclipse and Maven plugins of CobiGen utilize the Java ServiceLoader mechanic to find and register plugins at runtime. To enable a new plugin to be discovered by this mechanic the following steps are needed:\n\n\n\n\ncreate the file META-INF/services/com.devonfw.cobigen.api.extension.GeneratorPluginActivator containing just the full qualified name of the class implementing the GeneratorPluginActivator interface, if the plugin provides a Merger and/or a TriggerInterpreter\n\n\ncreate the file META-INF/services/com.devonfw.cobigen.api.extension.TextTemplateEngine containing just the full qualified name of the class implementing the TextTemplateEngine interface, if provided by the plugin\n\n\ninclude META-INF into the target bundle (i.e. the folder META-INF has to be present in the target jar file)\n\n\n\n\n\nExample: Java Plugin\n\nThe java plugin provides both a Merger and a TriggerInterpreter. It contains therefore a com.devonfw.cobigen.api.extension.GeneratorPluginActivator file with the following content:\n\n\n\n\n\n\n\nThis makes the JavaPluginActivator class discoverable by the ServiceLoader at runtime.\n\n\n\n\n\n\nto properly include the plugin into the current system and use existing infrastructure, you need to add the plugin as a module in /cobigen/pom.xml (in case of a Merger/TriggerInterpreter providing plugin) and declare that as the plugin’s parent in it’s own pom.xml via\n\n\n\n\n\n\n\n\n\nor /cobigen/cobigen-templateengines/pom.xml (in case of a Merger/TriggerInterpreter providing plugin) and declare that as the plugin’s parent in it’s own pom.xml via\n\n\n\n\n\n\n\nIf the plugin provides both just use the /cobigen/pom.xml.\n\n\n\n\nThe dependencies of the plugin are included in the bundle\n\n\nTo make the plugin available to the Eclipse plugin it must be included into the current compositeContent.xml and compositeArtifacts.xml files. Both files are located in https://github.com/devonfw/cobigen/tree/gh-pages/updatesite/{test|stable}. To do so, add an &lt;child&gt; entry to the &lt;children&gt; tag in both files and adapt the size attribute to match the new number of references. The location attribute of the new &lt;child&gt; tag needs to be the artifact id of the plugins pom.xml.\n\n\n\n\n\nExample: Java Plugin\n\nIn case of the Java plugin, the entry is\n\n\n\n\n\n\n\n\n\nDeployment\n\nIf you want to create a test release of eclipse you need to run the command\n\n\n\n\n\n\n\non the cloned CobiGen repository while making sure, that your current version of CobiGen cloned is a snapshot version. This will automatically be detected by the deploy script.\n\n\n\n\n\n\n"}