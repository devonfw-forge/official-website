{"type":"doc","filename":"devonfw-guide_devon4j.wiki_guide-json.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_guide-json.asciidoc_custom-mapping","title":"Custom Mapping","breadcrumbs":["Java","General","JSON"],"text":"Custom Mapping\n\nIn order to map custom datatypes or other types that do not follow the Java bean conventions, you need to define a custom mapping. If you create objects dedicated for the JSON mapping you can easily avoid such situations. When this is not suitable follow these instructions to define the mapping:\n\n\n\n\nAs an example, the use of JSR354 (javax.money) is appreciated in order to process monetary amounts properly. However, without custom mapping, the default mapping of Jackson will produce the following JSON for a MonetaryAmount:\n\n\n\n\n\n\nAs clearly can be seen, the JSON contains too much information and reveals implementation secrets that do not belong here. Instead the JSON output expected and desired would be:\n\n\n\n\n\n\n\nEven worse, when we send the JSON data to the server, Jackson will see that MonetaryAmount is an interface and does not know how to instantiate it so the request will fail.\nTherefore we need a customized Serializer.\n\n\n\nWe implement MonetaryAmountJsonSerializer to define how a MonetaryAmount is serialized to JSON:\n\n\n\n\n\n\nFor composite datatypes it is important to wrap the info as an object (writeStartObject() and writeEndObject()). MonetaryAmount provides the information we need by the getCurrency() and getNumber(). So that we can easily write them into the JSON data.\n\n\n\nNext, we implement MonetaryAmountJsonDeserializer to define how a MonetaryAmount is deserialized back as Java object from JSON:\n\n\n\n\n\n\nFor composite datatypes we extend from AbstractJsonDeserializer as this makes our task easier. So we already get a JsonNode with the parsed payload of our datatype. Based on this API it is easy to retrieve individual fields from the payload without taking care of their order, etc.\nAbstractJsonDeserializer also provides methods such as getRequiredValue to read required fields and get them converted to the desired basis datatype. So we can easily read the amount and currency and construct an instance of MonetaryAmount via the official factory API.\n\n\n\nFinally we need to register our custom (de)serializers with the following configuration code in the constructor of ApplicationObjectMapperFactory:+\n\n\n\n\n\n\n\n\n\nNow we can read and write MonetaryAmount from and to JSON as expected.\n\n\n\n\n\n\n"}