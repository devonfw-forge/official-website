{"type":"doc","filename":"devonfw-guide_devon4net.wiki_architecture_guide.asciidoc.html","anchor":"devonfw-guide_devon4net.wiki_architecture_guide.asciidoc_onion-architecture","title":"Onion Architecture","breadcrumbs":[".net","Architecture basics","Architecture"],"text":"Onion Architecture\n\nAs the name suggests, the proposed architecture makes use of cooperating components called layers, just like an onion.\n\n\n\nIt is important to understand the difference between layers and tiers. Layers describe the logical groupings of the functionality and components in an application; whereas tiers describe the physical distribution of the functionality and components on separate servers, computers, networks, or remote locations. Although both layers and tiers use the same set of names (presentation, business, services, and data), remember that only tiers imply a physical separation. It is quite common to locate more than one layer on the same physical machine (the same tier). You can think of the term tier as referring to physical distribution patterns such as two-tier, three-tier, and n-tier.\n\n\n— Layered Application Guidelines\nMSDN Microsoft\n\n\n\nThe main objective is to control the coupling in such way that the high-level modules do not rely on low level ones, but rather on abstractions of them. Components in a loosely coupled system can be replaced with alternative implementations that provide the same services.\n\n\nThis principle is called Dependency Injection. To implement it, we will also be using the Dependency Injection pattern available in .NET Core.\n\n\nDomain Layer\n\nThis type of architecture also follows Domain-Driven-Design (DDD) principles, so we can find the Domain Model in the very center. It represents the state and behavior combination that models truth for the organization.\n\n\n\n\n\nFigure 8. Domain Layer diagram\n\n\nAs shown in the diagram, the entities and the database context that provides access to an external database are placed in the core of the application. Repository contracts (interfaces) that provide object saving and retrieving behavior can also be found in this layer.\n\n\nThe Domain Model is only coupled to itself, so it doesn’t have any dependency on other application layers.\n\n\n\nData Layer\n\nThe first layer around the Domain Model is typically the one that orchestrates the data obtained from the database, betweeen the Domain Layer and the Business Layer.\n\n\n\n\n\nFigure 9. Data Layer diagram\n\n\nTo provide an abstraction of the data access methods, the Repository Pattern is being used. In this layer the implementations of the repository interfaces are found. As well as any other necesary implementation such as the Unit of Work.\n\n\n\nBusiness Layer\n\nThe business layer holds all the application logic and core functionality. It may implement each required API controller as well as the services that go along with them.\n\n\nSometimes services or interfaces defined at this layer will need to work with non-entity types. These objects are known as data transfer objects (DTOs) and they are used to decouple the logic from the domain. This enables the data to be optimized and made available to a variety of data users. Thanks to a series of converters, the data can be optimized and be ready for different consumers.\n\n\n\n\n\nFigure 10. Business Layer diagram\n\n\n\nApplication Layer\n\nThe outer layer of our onion encapsulates the different front-end clients and its resource dependencies. Following also Test-Driven-Development (TDD) principles we will find the Tests.\n\n\n\n\n\nFigure 11. Application Layer diagram\n\n\nAs shown in the diagram, this layer may use many external components such as data sources, identity providers and other services.\n\n\n\n\n"}