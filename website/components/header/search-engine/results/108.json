{"type":"doc","filename":"devonfw-guide_devon4j.wiki_devon4j.asciidoc_layers.html","anchor":"devonfw-guide_devon4j.wiki_guide-service-layer.asciidoc","title":"Service Layer","breadcrumbs":["Java","Spring","Layers"],"text":"Service Layer\n\nThe service layer is responsible for exposing functionality made available by the logical layer to external consumers over a network via technical protocols.\n\n\nTypes of Services\n\nBefore you start creating your services you should consider some general design aspects:\n\n\n\n\nDo you want to create a RPC service?\n\n\nOr is your problem better addressed by messaging or eventing?\n\n\nWho will consume your service?\n\n\n\nDo you have one or multiple consumers?\n\n\nDo web-browsers have to use your service?\n\n\nWill apps from other vendors or parties have to consume your service that you can not influence if the service may have to change or be extended?\n\n\n\n\n\n\n\nFor RPC a common choice is REST but there are also interesting alternatives like gRPC. We also have a guide for SOAP but this technology should rather be considered as legacy and is not recommended for new services.\n\n\nWhen it comes to messaging in Java the typical answer will be JMS. However, a very promising alternative is Kafka.\n\n\n\nVersioning\n\nFor RPC services consumed by other applications we use versioning to prevent incompatibilities between applications when deploying updates. This is done by the following conventions:\n\n\n\n\nWe define a version number and prefix it with v (e.g. v1).\n\n\nIf we support previous versions we use that version numbers as part of the Java package defining the service API (e.g. com.foo.application.component.service.api.v1)\n\n\nWe use the version number as part of the service name in the remote URL (e.g. https://application.foo.com/services/rest/component/v1/resource)\n\n\nWhenever breaking changes are made to the API, create a separate version of the service and increment the version (e.g. v1 â†’ v2) . The implementations of the different versions of the service contain compatibility code and delegate to the same unversioned use-case of the logic layer whenever possible.\n\n\nFor maintenance and simplicity, avoid keeping more than one previous version.\n\n\n\n\n\nInteroperability\n\nFor services that are consumed by clients with different technology, interoperability is required. This is addressed by selecting the right protocol, following protocol-specific best practices and following our considerations especially simplicity.\n\n\n\nService Considerations\n\nThe term service is quite generic and therefore easily misunderstood. It is a unit exposing coherent functionality via a well-defined interface over a network. For the design of a service, we consider the following aspects:\n\n\n\n\nself-contained\nThe entire API of the service shall be self-contained and have no dependencies on other parts of the application (other services, implementations, etc.).\n\n\nidempotence\nE.g. creation of the same master-data entity has no effect (no error)\n\n\nloosely coupled\nService consumers have minimum knowledge and dependencies on the service provider.\n\n\nnormalized\nComplete, no redundancy, minimal\n\n\ncoarse-grained\nService provides rather large operations (save entire entity or set of entities rather than individual attributes)\n\n\natomic\nProcess individual entities (for processing large sets of data, use a batch instead of a service)\n\n\nsimplicity\nAvoid polymorphism, RPC methods with unique name per signature and no overloading, avoid attachments (consider separate download service), etc.\n\n\n\n\n\nSecurity\n\nYour services are the major entry point to your application. Hence, security considerations are important here.\n\n\nSee REST Security.\n\n\n\n\n\n"}