{"type":"doc","filename":"asciidoc_devonfw-guide_devon4j.wiki_devon4j.asciidoc_guides.html","anchor":"devonfw-guide_devon4j.wiki_guide-access-control.asciidoc","title":"Access-Control","breadcrumbs":["Java","Spring","Guides"],"text":"Access-Control\n\nAccess-Control is a central and important aspect of Security. It consists of two major aspects:\n\n\n\n\ndevonfw-guide_devon4j.wiki_guide-access-control.asciidoc_Authentication (Who tries to access?)\n\n\ndevonfw-guide_devon4j.wiki_guide-access-control.asciidoc_Authorization (Is the one accessing allowed to do what he wants to do?)\n\n\n\n\nAuthentication\n\nDefinition:\n\n\n\n\nAuthentication is the verification that somebody interacting with the system is the actual subject for whom he claims to be.\n\n\n\n\nThe one authenticated is properly called subject or principal. There are two forms of principals you need to distinguish while designing your authentication: human users and autonomous systems. While e.g. a Kerberos/SPNEGO Single-Sign-On makes sense for human users, it is pointless for authenticating autonomous systems.  For simplicity, we use the common term user to refer to any principal even though it may not be a human (e.g. in case of a service call from an external system).\n\n\nTo prove the authenticity, the user provides some secret called credentials. The most simple form of credentials is a password.\n\n\nImplementations\n\n\n\n\nNote\n\n\nPlease never implement your own authentication mechanism or credential store. You have to be aware of implicit demands such as salting and hashing credentials, password life-cycle with recovery, expiry, and renewal including email notification confirmation tokens, central password policies, etc. This is the domain of identity and access management (IAM). There are various existing products for IAM that already solve the problems better than you could ever implement it yourselve. In a business context you will typically already find a system for this purpose that you have to integrate (e.g. via JWT and OAuth). In case you have the freedom of choice, we recommend using keycloak.\n\n\n\n\n\nWe recommend using JWT when possible. For KISS, also try to avoid combining multiple authentication mechanisms (form based, basic-auth, SAMLv2, OAuth, etc.) within the same application (for different URLs).\nPlease note that inside an identity and access management (IAM) you have many different options for authentication.\nIn case you are in charge of making decisions considere the following options according to your requirements and demands (esp. security):\n\n\n\n\nConsider if a second factor (e.g. via TOTP and according free mobile apps) should be used for advanced security\n\n\nConsider if Fido2 is an option to get rid of passwords and increase security.\n\n\n\n\nFor spring, check the Spring Security\n\n\nFor quarkus, check the Quarkus Authentication\n\n\n\n\nAuthorization\n\nDefinition:\n\n\n\n\nAuthorization is the verification that an authenticated user is allowed to perform the operation he intends to invoke.\n\n\n\n\nClarification of terms\n\nFor clarification we also want to give a common understanding of related terms that have no unique definition and consistent usage in the wild.\n\n\nTable 46. Security terms related to authorization\n\n\n\n\n\n\nTerm\nMeaning and comment\n\n\n\n\nPermission\nA permission is an object that allows a principal to perform an operation in the system. This permission can be granted (give) or revoked (taken away). Sometimes people also use the term right what is actually wrong as a right (such as the right to be free) can not be revoked.\n\n\nGroup\nWe use the term group in this context for an object that contains permissions. A group may also contain other groups. Then the group represents the set of all recursively contained permissions.\n\n\nRole\nWe consider a role as a specific form of group that also contains permissions. A role identifies a specific function of a principal. A user can act in a role.\nFor simple scenarios a principal has a single role associated. In more complex situations a principal can have multiple roles but has only one active role at a time that he can choose out of his assigned roles. For KISS it is sometimes sufficient to avoid this by creating multiple accounts for the few users with multiple roles. Otherwise at least avoid switching roles at run-time in clients as this may cause problems with related states. Simply restart the client with the new role as parameter in case the user wants to switch his role.\n\n\nAccess Control\nAny permission, group, role, etc., which declares a control for access management.\n\n\n\n\n\nSuggestions on the access model\n\nFor the access model we give the following suggestions:\n\n\n\n\nEach Access Control (permission, group, role, …​) is uniquely identified by a human readable string.\n\n\nWe create a unique permission for each use-case.\n\n\nWe define groups that combine permissions to typical and useful sets for the users.\n\n\nWe define roles as specific groups as required by our business demands.\n\n\nWe allow to associate users with a list of Access Controls.\n\n\nFor authorization of an implemented use case we determine the required permission. Furthermore, we determine the current user and verify that the required permission is contained in the tree spanned by all his associated Access Controls. If the user does not have the permission we throw a security exception and thus abort the operation and transaction.\n\n\nWe avoid negative permissions, that is a user has no permission by default and only those granted to him explicitly give him additional permission for specific things. Permissions granted can not be reduced by other permissions.\n\n\nTechnically we consider permissions as a secret of the application. Administrators shall not fiddle with individual permissions but grant them via groups. So the access management provides a list of strings identifying the Access Controls of a user. The individual application itself contains these Access Controls in a structured way, whereas each group forms a permission tree.\n\n\n\n\n\nNaming conventions\n\nAs stated above each Access Control is uniquely identified by a human readable string. This string should follow the naming convention:\n\n\n\n\n\n\n\nFor Access Control Permissions the «local-name» again follows the convention:\n\n\n\n\n\n\n\nThe segments are defined by the following table:\n\n\nTable 47. Segments of Access Control Permission ID\n\n\n\n\n\n\n\nSegment\nDescription\nExample\n\n\n\n\n«app-id»\nIs a unique technical but human readable string of the application (or microservice). It shall not contain special characters and especially no dot or whitespace. We recommend to use lower-train-case-ascii-syntax. The identity and access management should be organized on enterprise level rather than application level. Therefore permissions of different apps might easily clash (e.g. two apps might both define a group ReadMasterData but some user shall get this group for only one of these two apps). Using the «app-id». prefix is a simple but powerful namespacing concept that allows you to scale and grow. You may also reserve specific «app-id»s for cross-cutting concerns that do not actually reflect a single app e.g to grant access to a geographic region.\nshop\n\n\n«verb»\nThe action that is to be performed on «object». We use Find for searching and reading data. Save shall be used both for create and update. Only if you really have demands to separate these two you may use Create in addition to Save. Finally, Delete is used for deletions. For non CRUD actions you are free to use additional verbs such as Approve or Reject.\nFind\n\n\n«object»\nThe affected object or entity. Shall be named according to your data-model\nProduct\n\n\n\n\nSo as an example shop.FindProduct will reflect the permission to search and retrieve a Product in the shop application. The group shop.ReadMasterData may combine all permissions to read master-data from the shop. However, also a group shop.Admin may exist for the Admin role of the shop application. Here the «local-name» is Admin that does not follow the «verb»«object» schema.\n\n\n\ndevon4j-security\n\nThe module devon4j-security provides ready-to-use code based on spring-security that makes your life a lot easier.\n\n\n\n\n\nFigure 9. devon4j Security Model\n\n\nThe diagram shows the model of devon4j-security that separates two different aspects:\n\n\n\n\nThe Identity- and Access-Management is provided by according products and typically already available in the enterprise landscape (e.g. an active directory). It provides a hierarchy of primary access control objects (roles and groups) of a user. An administrator can grant and revoke permissions (indirectly) via this way.\n\n\nThe application security defines a hierarchy of secondary access control objects (groups and permissions). This is done by configuration owned by the application (see following section). The \"API\" is defined by the IDs of the primary access control objects that will be referenced from the Identity- and Access-Management.\n\n\n\n\n\nAccess Control Config\n\nIn your application simply extend AccessControlConfig to configure your access control objects as code and reference it from your use-cases. An example config may look like this:\n\n\n\n\n\n\n\n\nConfiguration on Java Method level\n\nIn your use-case you can now reference a permission like this:\n\n\n\n\n\n\n\n\nJEE Standard\n\nRole-based Access Control (RBAC) is commonly used for authorization.\nJSR 250 defines a number of common annotations to secure your application.\n\n\n\n\njavax.annotation.security.PermitAll specifies that no access control is required to invoke the specified method(s).\n\n\njavax.annotation.security.DenyAll specifies that no access controls are allowed to invoke the specified method(s).\n\n\njavax.annotation.security.RolesAllowed specifies that only a list of access controls are allowed to invoke the specified method(s).\n\n\njavax.annotation.security.DeclareRoles defines roles for security checking.\n\n\njavax.annotation.security.RunAs specifies the RunAs role for the given components.\n\n\n\n\n@PermitAll, @Denyall, and @RolesAllowed annotations can be applied to both class and method.\nA method-level annotation will override the behaviour of class-level annotation. Using multiple annotations of those 3 is not valid.\n\n\n\n\n\n\n\nPlease note that when specifying multiple arguments to @RolesAllowed those are combined with OR (and not with AND).\nSo if the user has any of the specified access controls, he will be able to access the method.\n\n\nAs a best practice avoid specifying string literals to @RolesAllowed.\nInstead define a class with all access controls as constants and reference them from there.\nThis class is typically called ApplicationAccessControlConfig in devonfw.\n\n\nIn many complicated cases where @PermitAll @DenyAll @RolesAllowed are insufficient e.g. a method should be accessed by a user in role A and not in role B at the same time, you have to verify the user role directly in the method. You can use SecurityContext class to get further needed information.\n\n\nSpring\n\nSpring Security also supports authorization on method level. To use it, you need to add the spring-security-config dependency. If you use Spring Boot, the dependency spring-boot-starter-security already includes spring-security-config. Then you can configure as follows:\n\n\n\n\nprePostEnabled property enables Spring Security pre/post annotations. @PreAuthorize and @PostAuthorize annotations provide expression-based access control. See more here\n\n\nsecuredEnabled property determines if the @Secured annotation should be enabled. @Secured can be used similarly as @RollesAllowed.\n\n\njsr250Enabled property allows us to use the JSR-250 annotations such as @RolesAllowed.\n\n\n\n\n\n\n\n\n\nA further read about the whole concept of Spring Security Authorization can be found here.\n\n\n\nQuarkus\n\nQuarkus comes with built-in security to allow for RBAC based on the common security annotations @RolesAllowed, @DenyAll, @PermitAll on REST endpoints and CDI beans. Quarkus also provides the io.quarkus.security.Authenticated annotation that will permit any authenticated user to access the resource (equivalent to @RolesAllowed(\"**\")).\n\n\n\n\nData-based Permissions\n\nSee data permissions\n\n\n\nAccess Control Schema (deprecated)\n\nThe access-control-schema.xml approach is deprecated. The documentation can still be found in access control schema.\n\n\n\n\n\n\nData-permissions\n\nIn some projects there are demands for permissions and authorization that is dependent on the processed data. E.g. a user may only be allowed to read or write data for a specific region. This is adding some additional complexity to your authorization. If you can avoid this it is always best to keep things simple. However, in various cases this is a requirement. Therefore the following sections give you guidance and patterns how to solve this properly.\n\n\nStructuring your data\n\nFor all your business objects (entities) that have to be secured regarding to data permissions we recommend that you create a separate interface that provides access to the relevant data required to decide about the permission. Here is a simple example:\n\n\n\n\n\n\n\nNow related business objects (entities) can implement this interface. Often such data-permissions have to be applied to an entire object-hierarchy. For security reasons we recommend that also all child-objects implement this interface. For performance reasons we recommend that the child-objects redundantly store the data-permission properties (such as country in the example above) and this gets simply propagated from the parent, when a child object is created.\n\n\n\nPermissions for processing data\n\nWhen saving or processing objects with a data-permission, we recommend to provide dedicated methods to verify the permission in an abstract base-class such as AbstractUc and simply call this explicitly from your business code. This makes it easy to understand and debug the code. Here is a simple example:\n\n\n\n\n\n\n\nBeware of AOP\n\nFor simple but cross-cutting data-permissions you may also use AOP. This leads to programming aspects that reflectively scan method arguments and magically decide what to do. Be aware that this quickly gets tricky:\n\n\n\n\nWhat if multiple of your method arguments have data-permissions (e.g. implement SecurityDataPermission*)?\n\n\nWhat if the object to authorize is only provided as reference (e.g. Long or IdRef) and only loaded and processed inside the implementation where the AOP aspect does not apply?\n\n\nHow to express advanced data-permissions in annotations?\n\n\n\n\nWhat we have learned is that annotations like @PreAuthorize from spring-security easily lead to the \"programming in string literals\" anti-pattern. We strongly discourage to use this anti-pattern. In such case writing your own verifyPermission methods that you manually call in the right places of your business-logic is much better to understand, debug and maintain.\n\n\n\n\nPermissions for reading data\n\nWhen it comes to restrictions on the data to read it becomes even more tricky. In the context of a user only entities shall be loaded from the database he is permitted to read. This is simple for loading a single entity (e.g. by its ID) as you can load it and then if not permitted throw an exception to secure your code. But what if the user is performing a search query to find many entities? For performance reasons we should only find data the user is permitted to read and filter all the rest already via the database query. But what if this is not a requirement for a single query but needs to be applied cross-cutting to tons of queries? Therefore we have the following pattern that solves your problem:\n\n\nFor each data-permission attribute (or set of such) we create an abstract base entity:\n\n\n\n\n\n\n\nThere are some special hibernate annotations @EntityListeners, @FilterDef, and @Filter used here allowing to apply a filter on the country for any (non-native) query performed by hibernate. The entity listener may look like this:\n\n\n\n\n\n\n\nThis will ensure that hibernate implicitly will call these checks for every such entity when it is read from or written to the database. Further to avoid reading entities from the database the user is not permitted to (and ending up with exceptions), we create an AOP aspect that automatically activates the above declared hibernate filter:\n\n\n\n\n\n\n\nFinally to apply this aspect to all Repositories (can easily be changed to DAOs) implement the following advisor:\n\n\n\n\n\n\n\n\nManaging and granting the data-permissions\n\nFollowing our authorization guide we can simply create a permission for each country. We might simply reserve a prefix (as virtual «app-id») for each data-permission to allow granting data-permissions to end-users across all applications of the IT landscape. In our example we could create access controls country.DE, country.US, country.ES, etc. and assign those to the users. The method permissionChecker.getPermittedCountriesForReading() would then scan for these access controls and only return the 2-letter country code from it.\n\n\n\n\n\nCaution\n\n\nBefore you make your decisions how to design your access controls please clarify the following questions:\n\n\n\n\n\n\n\nDo you need to separate data-permissions independent of the functional permissions? E.g. may it be required to express that a user can read data from the countries ES and PL but is only permitted to modify data from PL? In such case a single assignment of \"country-permissions\" to users is insufficient.\n\n\nDo you want to grant data-permissions individually for each application (higher flexibility and complexity) or for the entire application landscape (simplicity, better maintenance for administrators)? In case of the first approach you would rather have access controls like app1.country.GB and app2.country.GB.\n\n\nDo your data-permissions depend on objects that can be created dynamically inside your application?\n\n\nIf you want to grant data-permissions on other business objects (entities), how do you want to reference them (primary keys, business keys, etc.)? What reference is most stable? Which is most readable?\n\n\n\n\n\n\n\n\n\n"}