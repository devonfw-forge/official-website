{"type":"doc","filename":"devonfw-guide_devon4j.wiki_coding-conventions.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_coding-conventions.asciidoc_code-style","title":"Code-Style","breadcrumbs":["Java","General","Coding Conventions"],"text":"Code-Style\n\nThis section gives you best practices to write better code and avoid pitfalls and mistakes.\n\n\nBLOBs\n\nAvoid using byte[] for BLOBs as this will load them entirely into your memory. This will cause performance issues or out of memory errors. Instead, use streams when dealing with BLOBs. For further details see BLOB support.\n\n\n\nStateless Programming\n\nWhen implementing logic as components or beans of your container using dependency injection, we strongly encourage stateless programming.\nThis is not about data objects like an entity or transfer-object that are stateful by design.\nInstead this applies to all classes annotated with @Named, @ApplicationScoped, @Stateless, etc. and all their super-classes.\nThese classes especially include your repositories, use-cases, and REST services.\nSuch classes shall never be modified after initialization.\nMethods called at runtime (after initialization via the container) do not assign fields (member variables of your class) or mutate the object stored in a field.\nThis allows your component or bean to be stateless and thread-safe.\nTherefore it can be initialized as a singleton so only one instance is created and shared accross all threads of the application.\nHere is an example:\n\n\n\n\n\n\n\nAs you can see in the bad code fields of the class are assigned when the method approve is called.\nSo mutliple users and therefore threads calling this method concurrently can interfere and override this state causing side-effects on parallel threads.\nThis will lead to nasty bugs and errors that are hard to trace down.\nThey will not occur in simple tests but for sure in production with real users.\nTherefore never do this and implement your functionality stateless.\nThat is keeping all state in local variables and strictly avoid modifying fields or their value as illustrated in the fine code.\nIf you find yourself passing many parameters between methods that all represent state, you can easily create a separate class that encapsulates this state.\nHowever, then you need to create this state object in your method as local variable and pass it between methods as parameter:\n\n\n\n\n\n\n\n\nClosing Resources\n\nResources such as streams (InputStream, OutputStream, Reader, Writer) or transactions need to be handled properly. Therefore, it is important to follow these rules:\n\n\n\n\nEach resource has to be closed properly, otherwise you will get out of file handles, TX sessions, memory leaks or the like\n\n\nWhere possible avoid to deal with such resources manually. That is why we are recommending @Transactional for transactions in devonfw (see Transaction Handling).\n\n\nIn case you have to deal with resources manually (e.g. binary streams) ensure to close them properly. See the example below for details.\n\n\n\n\nClosing streams and other such resources is error prone. Have a look at the following example:\n\n\n\n\n\n\n\nThe code above is wrong as in case of an IOException the InputStream is not properly closed. In a server application such mistakes can cause severe errors that typically will only occur in production. As such resources implement the AutoCloseable interface you can use the try-with-resource syntax to write correct code. The following code shows a correct version of the example:\n\n\n\n\n\n\n\n\nCatching and handling Exceptions\n\nWhen catching exceptions always ensure the following:\n\n\n\n\nNever call printStackTrace() method on an exception\n\n\nEither log or wrap and re-throw the entire catched exception. Be aware that the cause(s) of an exception is very valuable information. If you loose such information by improper exception-handling you may be unable to properly analyse production problems what can cause severe issues.\n\n\n\nIf you wrap and re-throw an exception ensure that the catched exception is passed as cause to the newly created and thrown exception.\n\n\nIf you log an exception ensure that the entire exception is passed as argument to the logger (and not only the result of getMessage() or toString() on the exception).\n\n\n\n\n\nSee exception handling\n\n\n\n\n\nLambdas and Streams\n\nWith Java8 you have cool new features like lambdas and monads like (Stream, CompletableFuture, Optional, etc.).\nHowever, these new features can also be misused or led to code that is hard to read or debug. To avoid pain, we give you the following best practices:\n\n\n\n\nLearn how to use the new features properly before using. Developers are often keen on using cool new features. When you do your first experiments in your project code you will cause deep pain and might be ashamed afterwards. Please study the features properly. Even Java8 experts still write for loops to iterate over collections, so only use these features where it really makes sense.\n\n\nStreams shall only be used in fluent API calls as a Stream can not be forked or reused.\n\n\nEach stream has to have exactly one terminal operation.\n\n\nDo not write multiple statements into lambda code:\n\n\n\n\n\n\nThis style makes the code hard to read and debug. Never do that! Instead, extract the lambda body to a private method with a meaningful name:\n\n\n\n\n\n\n\n\nDo not use parallelStream() in general code (that will run on server side) unless you know exactly what you are doing and what is going on under the hood. Some developers might think that using parallel streams is a good idea as it will make the code faster. However, if you want to do performance optimizations talk to your technical lead (architect). Many features such as security and transactions will rely on contextual information that is associated with the current thread. Hence, using parallel streams will most probably cause serious bugs. Only use them for standalone (CLI) applications or for code that is just processing large amounts of data.\n\n\nDo not perform operations on a sub-stream inside a lambda:\n\n\n\n\n\n\n\nOnly use collect at the end of the stream:\n\n\n\n\n\n\n\nLambda parameters with Types inference\n\n\n\n\n\n\n\nAvoid Return Braces and Statement\n\n\n\n\n\n\n\nAvoid Parentheses with Single Parameter\n\n\n\n\n\n\n\nAvoid if/else inside foreach method. Use Filter method &amp; comprehension\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOptionals\n\nWith Optional you can wrap values to avoid a NullPointerException (NPE). However, it is not a good code-style to use Optional for every parameter or result to express that it may be null. For such case use @Nullable or even better instead annotate @NotNull where null is not acceptable.\n\n\nHowever, Optional can be used to prevent NPEs in fluent calls (due to the lack of the elvis operator):\n\n\n\n\n\n\n\n\nEncoding\n\nEncoding (esp. Unicode with combining characters and surrogates) is a complex topic. Please study this topic if you have to deal with encodings and processing of special characters. For the basics follow these recommendations:\n\n\n\n\nWhenever possible prefer unicode (UTF-8 or better) as encoding. This especially impacts your databases and has to be defined upfront as it typically can not be changed (easily) afterwards.\n\n\nDo not cast from byte to char (unicode characters can be composed of multiple bytes, such cast may only work for ASCII characters)\n\n\nNever convert the case of a String using the default locale (esp. when writing generic code like in devonfw). E.g. if you do \"HI\".toLowerCase() and your system locale is Turkish, then the output will be \"hÄ±\" instead of \"hi\", which can lead to wrong assumptions and serious problems. If you want to do a \"universal\" case conversion always explicitly use an according western locale (e.g. toLowerCase(Locale.US)). Consider using a helper class (see e.g. CaseHelper) or create your own little static utility for that in your project.\n\n\nWrite your code independent from the default encoding (system property file.encoding) - this will most likely differ in JUnit from production environment\n\n\n\nAlways provide an encoding when you create a String from byte[]: new String(bytes, encoding)\n\n\nAlways provide an encoding when you create a Reader or Writer : new InputStreamReader(inStream, encoding)\n\n\n\n\n\n\n\n\nPrefer general API\n\nAvoid unnecessary strong bindings:\n\n\n\n\nDo not bind your code to implementations such as Vector or ArrayList instead of List\n\n\nIn APIs for input (=parameters) always consider to make little assumptions:\n\n\n\nprefer Collection over List or Set where the difference does not matter (e.g. only use Set when you require uniqueness or highly efficient contains)\n\n\nconsider preferring Collection&lt;? extends Foo&gt; over Collection&lt;Foo&gt; when Foo is an interface or super-class\n\n\n\n\n\n\n\n\nPrefer primitive boolean\n\nUnless in rare cases where you need to allow a flag being null avoid using the object type Boolean.\n\n\n\n\n\n\n\nInstead always use the primitive boolean type:\n\n\n\n\n\n\n\nThe only known excuse is for flags in embeddable types due to limitations of hibernate.\n\n\n\n\n\n\n"}