{"type":"doc","filename":"devonfw-guide_mrchecker.wiki_master-mrchecker.asciidoc_test-framework-modules.html","anchor":"devonfw-guide_mrchecker.wiki_master-mrchecker.asciidoc_selenium-structure","title":"Selenium Structure","breadcrumbs":["Tools","MrChecker - devonfw testing tool","Test Framework Modules"],"text":"Selenium Structure\n\nWhat is Selenium\n\nSelenium is a framework for testing browser applications. The test automation supports:\n\n\n\n\nFrequent regression testing\n\n\nRepeating test case executions\n\n\nDocumentation of test cases\n\n\nFinding defects\n\n\nMultiple Browsers\n\n\n\n\nThe Selenium testing framework consists of multiple tools:\n\n\n\n\nSelenium IDE\n\nThe Selenium Integrated Development Environment is a prototyping tool for building test scripts. It is a Firefox Plugin and provides an easy-to-use interface for developing test cases. Additionally, Selenium IDE contains a recording feature, that allows the user to record user inputs that can be automatically re-executed in future.\n\n\n\nSelenium 1\n\nSelenium 1, also known as Selenium RC, commands a Selenium Server to launch and kill browsers, interpreting the Selenese commands passed from the test program. The Server acts as an HTTP proxy. This tool is deprecated.\n\n\n\nSelenium 2\n\nSelenium 2, also known as Selenium WebDriver, is designed to supply a well-designed, object-oriented API that provides improved support for modern advanced web-app testing problems.\n\n\n\nSelenium 3.0\n\nThe major change in Selenium 3.0 is removing the original Selenium Core implementation and replacing it with one backed by WebDriver. There is now a W3C specification for browser automation, based on the Open Source WebDriver.\n\n\n\nSelenium Grid\n\nSelenium Grid allows the scaling of Selenium RC test cases, that must be run in multiple and potentially variable environments. The tests can be run in parallel on different remote machines.\n\n\n\n\n\nSelenium on the Production Line\n\nMore information on Selenium on the Production Line can be found here.\n\n\ntl;dr\n\n\nThe Production Line has containers running Chrome and Firefox Selenium Nodes. The communication with these nodes is accomplished using Selenium Grid.\n\n\nHaving issues using Selenium on the Production Line? Check the Production Line issue list, maybe it’s a known issue that can be worked around.\n\n\n\n\nWhat is WebDriver\n\nOn the one hand, it is a very convenient API for a programmer that allows for interaction with the browser, on the other hand it is a driver concept that enables this direct communication.\n\n\n\n\n\n\n\nHow does it work?\n\n\n\n\n\n\nA tester, through their test script, can command WebDriver to perform certain actions on the WAUT on a certain browser. The way the user can command WebDriver to perform something is by using the client libraries or language bindings provided by WebDriver.\n\n\nBy using the language-binding client libraries, a tester can invoke browser-specific implementations of WebDriver, such as Firefox Driver, IE Driver, Opera Driver, and so on, to interact with the WAUT of the respective browser. These browser-specific implementations of WebDriver will work with the browser natively and execute commands from outside the browser to simulate exactly what the application user does.\n\n\nAfter execution, WebDriver will send the test result back to the test script for developer’s analysis.\n\n\n\n\nWhat is Page Object Model?\n\n\n\n\n\n\nCreating Selenium test cases can result in an unmaintainable project. One of the reasons is that too much duplicated code is used. Duplicated code could result from duplicated functionality leading to duplicated usage of locators. The main disadvantage of duplicated code is that the project is less maintainable. If a locator changes, you have to walk through the whole test code to adjust locators where necessary. By using the page object model we can make non-brittle test code and reduce or eliminate duplicate test code. In addition, it improves the readability and allows us to create interactive documentation. Last but not least, we can create tests with less keystroke. An implementation of the page object model can be achieved by separating the abstraction of the test object and the test scripts.\n\n\n\n\n\n\n\n\nBasic Web elements\n\nThis page will provide an overview of basic web elements.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nMethod to use element\n\n\n\n\nForm: Input Text\nelementInputText()\n\n\nForm: Label\nelementLabel()\n\n\nForm: Submit Button\nelementButton()\n\n\nPage: Button\nelementButton()\n\n\nCheckbox\nelementCheckbox()\n\n\nRadio\nelementRadioButton()\n\n\nElements (Tabs, Cards, Account, etc.)\nelementTab()\n\n\nDropdown List\nelementDropdownList()\n\n\nLink\n-\n\n\nCombobox\nelementList()\n\n\n\n\nComparision how picking value from checkbox can be done:\n\n\n\n\nby classic Selenium atomic actions\n\n\nby our enhanced Selenium wrapper\n\n\n\n\nClassic Selenium atomic actions\n\n\n\n\n\n\n\nEnhanced Selenium in E2E test framework\n\n\n\n\n\n\n\n\n\n"}