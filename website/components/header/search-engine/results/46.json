{"type":"doc","filename":"devonfw-guide_cobigen.wiki_master-cobigen.asciidoc_cobigen.html","anchor":"devonfw-guide_cobigen.wiki_cobigen-core_configuration.asciidoc","title":"Configuration","breadcrumbs":["Tools","CobiGen — Code-based incremental Generator","CobiGen"],"text":"Configuration\n\nCobiGen is maintaining a home directory further referenced in this documentation as $cghome, which is used to maintain temporary or transient data. The home folder is determined with the following location fall-back:\n\n\n\n\nSystem environment variable COBIGEN_HOME (e.g. C:\\project\\ide\\conf\\cobigen-home)\n\n\n.cobigen directory in OS user home (e.g. ~/.cobigen)\n\n\n\n\nThe actual configuration of CobiGen is maintained by a single folder or jar. The location can be configured with respect to the implemented configuration fall-back mechanism. CobiGen will search for the location of the configuration in the following order:\n\n\n\n\nA configuration jar or directory, which is passed to CobiGen by the Maven or Eclipse integration or any other program using the CobiGen programming interface:\n1.1. the Maven integration allows to configure a jar dependency to be included in the currently running classpath (of interest for maven configuration\n1.2. the Eclipse integration allows to specify a CobiGen_Templates project in the eclipse workspace\n\n\nThe file $cghome/.cobigen exists and the property templates is set to a valid configuration (e.g. templates=C:\\project\\ide\\conf\\templates or templates=C:\\project\\ide\\conf\\templates.jar) Hint: Check for log entry like Value of property templates in $cghome/.cobigen is invalid to identify an invalid configuration which is not taken up as expected\n\n\nThe folder $cghome/templates/CobiGen_Templates exists\n\n\nThe lexicographical sorted first configuration jar of the following path pattern $cghome/templates/templates-([^-]+)-(\\\\d+\\\\.?)+.jar if exists (e.g. templates-devon4j-2020.04.001)\n\n\nCobiGen will automatically download the latest jar configuration from maven central with groupId com.devonfw.cobigen and artifactId templates-devon4j and take it like described in 4.\n\n\n\n\nWithin the configuration jar or directory you will find the following structure:\n\n\n\n\n\n\n\nFind some examples here.\n\n\nContext Configuration\n\nThe context configuration (context.xml) always has the following root structure:\n\n\nListing 126. Context Configuration\n\n\n\n\n\nThe context configuration has a version attribute, which should match the XSD version the context configuration is an instance of. It should not state the version of the currently released version of CobiGen. This attribute should be maintained by the context configuration developers. If configured correctly, it will provide a better feedback for the user and thus higher user experience. Currently there is only the version v1.0. For further version there will be a changelog later on.\n\n\nTrigger Node\n\nAs children of the &lt;triggers&gt; node you can define different triggers. By defining a &lt;trigger&gt; you declare a mapping between special inputs and a templateFolder, which contains all templates, which are worth to be generated with the given input.\n\n\nListing 127. trigger configuration\n\n\n\n\n\n\n\nThe attribute id should be unique within an context configuration. It is necessary for efficient internal processing.\n\n\nThe attribute type declares a specific trigger interpreter, which might be provided by additional plug-ins. A trigger interpreter has to provide an input reader, which reads specific inputs and creates a template object model out of it to be processed by the FreeMarker template engine later on. Have a look at the plug-in’s documentation of your interest and see, which trigger types and thus inputs are currently supported.\n\n\nThe attribute templateFolder declares the relative path to the template folder, which will be used if the trigger gets activated.\n\n\nThe attribute inputCharset (optional) determines the charset to be used for reading any input file.\n\n\n\n\n\nMatcher Node\n\nA trigger will be activated if its matchers hold the following formula:\n\n\n!(NOT || …​ || NOT) &amp;&amp; AND &amp;&amp; …​ &amp;&amp; AND &amp;&amp; (OR || …​ || OR)\n\n\nWhereas NOT/AND/OR describes the accumulationType of a matcher (see below) and e.g. NOT means 'a matcher with accumulationType NOT matches a given input'. Thus additionally to an input reader, a trigger interpreter has to define at least one set of matchers, which are satisfiable, to be fully functional. A &lt;matcher&gt; node declares a specific characteristics a valid input should have.\n\n\nListing 128. Matcher Configuration\n\n\n\n\n\n\n\nThe attribute type declares a specific type of matcher, which has to be provided by the surrounding trigger interpreter. Have a look at the plug-in’s documentation, which also provides the used trigger type for more information about valid matcher and their functionalities.\n\n\nThe attribute value might contain any information necessary for processing the matcher’s functionality. Have a look at the relevant plug-in’s documentation for more detail.\n\n\nThe attribute accumulationType (optional) specifies how the matcher will influence the trigger activation. Valid values are:\n\n\n\nOR (default): if any matcher of accumulation type OR matches, the trigger will be activated as long as there are no further matchers with different accumulation types\n\n\nAND: if any matcher with AND accumulation type does not match, the trigger will not be activated\n\n\nNOT: if any matcher with NOT accumulation type matches, the trigger will not be activated\n\n\n\n\n\n\n\n\nVariable Assignment Node\n\nFinally, a &lt;matcher&gt; node can have multiple &lt;variableAssignment&gt; nodes as children. Variable assignments allow to parametrize the generation by additional values, which will be added to the object model for template processing. The variables declared using variable assignments, will be made accessible in the templates.xml as well in the object model for template processing via the namespace variables.*.\n\n\nListing 129. Complete Configuration Pattern\n\n\n\n\n\n\n\nThe attribute type declares the type of variable assignment to be processed by the trigger interpreter providing plug-in. This attribute enables variable assignments with different dynamic value resolutions.\n\n\nThe attribute key declares the namespace under which the resolved value will be accessible later on.\n\n\nThe attribute value might declare a constant value to be assigned or any hint for value resolution done by the trigger interpreter providing plug-in. For instance, if type is regex, then on value you will assign the matched group number by the regex (1, 2, 3…​)\n\n\n\n\n\nContainer Matcher Node\n\nThe &lt;containerMatcher&gt; node is an additional matcher for matching containers of multiple input objects.\nSuch a container might be a package, which encloses multiple types or---more generic---a model, which encloses multiple elements. A container matcher can be declared side by side with other matchers:\n\n\nListing 130. ContainerMatcher Declaration\n\n\n\n\n\n\n\nThe attribute type declares a specific type of matcher, which has to be provided by the surrounding trigger interpreter. Have a look at the plug-in’s documentation, which also provides the used trigger type for more information about valid matcher and their functionalities.\n\n\nThe attribute value might contain any information necessary for processing the matcher’s functionality. Have a look at the relevant plug-in’s documentation for more detail.\n\n\nThe attribute retrieveObjectsRecursively (optional boolean) states, whether the children of the input should be retrieved recursively to find matching inputs for generation.\n\n\n\n\nThe semantics of a container matchers are the following:\n\n\n\n\nA &lt;containerMatcher&gt; does not declare any &lt;variableAssignment&gt; nodes\n\n\nA &lt;containerMatcher&gt; matches an input if and only if one of its enclosed elements satisfies a set of &lt;matcher&gt; nodes of the same &lt;trigger&gt;\n\n\nInputs, which match a &lt;containerMatcher&gt; will cause a generation for each enclosed element\n\n\n\n\n\n\nTemplates Configuration\n\nThe template configuration (templates.xml) specifies, which templates exist and under which circumstances it will be generated. There are two possible configuration styles:\n\n\n\n\nConfigure the template meta-data for each template file by template nodes\n\n\n(since cobigen-core-v1.2.0): Configure templateScan nodes to automatically retrieve a default configuration for all files within a configured folder and possibly modify the automatically configured templates using templateExtension nodes\n\n\n\n\nTo get an intuition of the idea, the following will initially describe the first (more extensive) configuration style. Such an configuration root structure looks as follows:\n\n\nListing 131. Extensive Templates Configuration\n\n\n\n\n\nThe root node &lt;templatesConfiguration&gt; specifies two attributes. The attribute version provides further usability support and will be handled analogous to the version attribute of the context configuration. The optional attribute templateEngine specifies the template engine to be used for processing the templates (since `cobigen-core-4.0.0`). By default it is set to FreeMarker.\n\n\nThe node &lt;templatesConfiguration&gt; allows two different grouping nodes as children. First, there is the &lt;templates&gt; node, which groups all declarations of templates. Second, there is the &lt;increments&gt; node, which groups all declarations about increments.\n\n\nTemplate Node\n\nThe &lt;templates&gt; node groups multiple &lt;template&gt; declarations, which enables further generation. Each template file should be registered at least once as a template to be considered.\n\n\nListing 132. Example Template Configuration\n\n\n\n\n\nA template declaration consist of multiple information:\n\n\n\n\nThe attribute name specifies an unique ID within the templates configuration, which will later be reused in the increment definitions.\n\n\nThe attribute destinationPath specifies the destination path the template will be generated to. It is possible to use all variables defined by variable assignments within the path declaration using the FreeMarker syntax ${variables.*}. While resolving the variable expressions, each dot within the value will be automatically replaced by a slash. This behavior is accounted for by the transformations of Java packages to paths as CobiGen has first been developed in the context of the Java world. Furthermore, the destination path variable resolution provides the following additional built-in operators analogue to the FreeMarker syntax:\n\n\n\n?cap_first analogue to FreeMarker\n\n\n?uncap_first analogue to FreeMarker\n\n\n?lower_case analogue to FreeMarker\n\n\n?upper_case analogue to FreeMarker\n\n\n?replace(regex, replacement) - Replaces all occurrences of the regular expression regex in the variable’s value with the given replacement string. (since cobigen-core v1.1.0)\n\n\n?removeSuffix(suffix) - Removes the given suffix in the variable’s value iff the variable’s value ends with the given suffix. Otherwise nothing will happen. (since cobigen-core v1.1.0)\n\n\n?removePrefix(prefix) - Analogue to ?removeSuffix but removes the prefix of the variable’s value. (since cobigen-core v1.1.0)\n\n\n\n\n\nThe attribute templateFile describes the relative path dependent on the template folder specified in the trigger to the template file to be generated.\n\n\nThe attribute mergeStrategy (optional) can be optionally specified and declares the type of merge mechanism to be used, when the destinationPath points to an already existing file. CobiGen by itself just comes with a mergeStrategy override, which enforces file regeneration in total. Additional available merge strategies have to be obtained from the different plug-in’s documentations (see here for java, XML, properties, and text). Default: not set (means not mergeable)\n\n\nThe attribute targetCharset (optional) can be optionally specified and declares the encoding with which the contents will be written into the destination file. This also includes reading an existing file at the destination path for merging its contents with the newly generated ones. Default: UTF-8\n\n\n\n\n(Since version 4.1.0) It is possible to reference external template (templates defined on another trigger), thanks to using &lt;incrementRef …​&gt; that are explained here.\n\n\n\nTemplate Scan Node\n\n(since cobigen-core-v1.2.0)\n\n\nThe second configuration style for template meta-data is driven by initially scanning all available templates and automatically configure them with a default set of meta-data. A scanning configuration might look like this:\n\n\nListing 133. Example of Template-scan configuration\n\n\n\n\n\nYou can specify multiple &lt;templateScan …​&gt; nodes for different templatePaths and different templateNamePrefixes.\n\n\n\n\nThe name can be specified to later on reference the templates found by a template-scan within an increment. (since cobigen-core-v2.1.)\n\n\nThe templatePath specifies the relative path from the templates.xml to the root folder from which the template scan should be performed.\n\n\nThe templateNamePrefix (optional) defines a common id prefix, which will be added to all found and automatically configured templates.\n\n\nThe destinationPath defines the root folder all found templates should be generated to, whereas the root folder will be a prefix for all found and automatically configured templates.\n\n\n\n\nA templateScan will result in the following default configuration of templates. For each file found, new template will be created virtually with the following default values:\n\n\n\n\nid: file name without .ftl extension prefixed by templateNamePrefix from template-scan\n\n\ndestinationPath: relative file path of the file found with the prefix defined by destinationPath from template-scan. Furthermore,\n\n\n\nit is possible to use the syntax for accessing and modifying variables as described for the attribute destinationPath of the template node, besides the only difference, that due to file system restrictions you have to replace all ?-signs (for built-ins) with #-signs.\n\n\nthe files to be scanned, should provide their final file extension by the following file naming convention: &lt;filename&gt;.&lt;extension&gt;.ftl Thus the file extension .ftl will be removed after generation.\n\n\n\n\n\ntemplateFile: relative path to the file found\n\n\nmergeStrategy: (optional) not set means not mergeable\n\n\ntargetCharset:  (optional) defaults to UTF-8\n\n\n\n\n(Since version 4.1.0) It is possible to reference external templateScan (templateScans defined on another trigger), thanks to using &lt;incrementRef …​&gt; that are explained here.\n\n\n\nTemplate Extension Node\n\n(since cobigen-core-v1.2.0)\n\n\nAdditionally to the templateScan declaration it is easily possible to rewrite specific attributes for any scanned and automatically configured template.\n\n\nListing 134. Example Configuration of a TemplateExtension\n\n\n\n\n\nLets assume, that the above example declares a template-scan for the folder foo, which contains a file FooClass.java.ftl in any folder depth. Thus the template scan will automatically create a virtual template declaration with id=prefix_FooClass.java and further default configuration.\n\n\nUsing the templateExtension declaration above will reference the scanned template by the attribute ref and overrides the mergeStrategy of the automatically configured template by the value javamerge. Thus we are able to minimize the needed templates configuration.\n\n\n(Since version 4.1.0) It is possible to reference external templateExtension (templateExtensions defined on another trigger), thanks to using &lt;incrementRef …​&gt; that are explained here.\n\n\n\nIncrement Node\n\nThe &lt;increments&gt; node groups multiple &lt;increment&gt; nodes, which can be seen as a collection of templates to be generated. An increment will be defined by a unique id and a human readable description.\n\n\n\n\n\n\n\nAn increment might contain multiple increments and/or templates, which will be referenced using &lt;incrementRef …​&gt;, &lt;templateRef …​&gt;, resp. &lt;templateScanRef …​&gt; nodes. These nodes only declare the attribute ref, which will reference an increment, a template, or a template-scan by its id or name.\n\n\n(Since version 4.1.0)  An special case of &lt;incrementRef …​&gt; is the external incrementsRef. By default, &lt;incrementRef …​&gt; are used to reference increments defined in the same templates.xml file. So for example, we could have:\n\n\n\n\n\n\n\nHowever, if we want to reference an increment that it is not defined inside our templates.xml (an increment defined for another trigger), then we can use external incrementRef as shown below:\n\n\n\n\n\n\n\nThe ref string is split using as delimiter ::. The first part of the string, is the trigger_id to reference. That trigger contains an increment_id. Currently, this functionality only works when both templates use the same kind of input file.\n\n\n\n\nJava Template Logic\n\nsince cobigen-core-3.0.0 which is included in the Eclipse and Maven Plugin since version 2.0.0\nIn addition, it is possible to implement more complex template logic by custom Java code. To enable this feature, you can simply import the the CobiGen_Templates by clicking on Adapt Templates, turn it into a simple maven project (if it is not already) and implement any Java logic in the common maven layout (e.g. in the source folder src/main/java). Each Java class will be instantiated by CobiGen for each generation process. Thus, you can even store any state within a Java class instance during generation. However, there is currently no guarantee according to the template processing order.\n\n\nAs a consequence, you have to implement your Java classes with a public default (non-parameter) constructor to be used by any template. Methods of the implemented Java classes can be called within templates by the simple standard FreeMarker expression for calling Bean methods: SimpleType.methodName(param1). Until now, CobiGen will shadow multiple types with the same simple name non-deterministically. So please prevent yourself from that situation.\n\n\nFinally, if you would like to do some reflection within your Java code accessing any type of the template project or any type referenced by the input, you should load classes by making use of the classloader of the util classes. CobiGen will take care of the correct classloader building including the classpath of the input source as well as of the classpath of the template project. If you use any other classloader or build it by your own, there will be no guarantee, that generation succeeds.\n\n\n\nTemplate Properties\n\nsince cobigen-core-4.0.0`\nUsing a configuration with `template scan, you can make use of properties in templates specified in property files named cobigen.properties next to the templates. The property files are specified as Java property files. Property files can be nested in sub-folders. Properties will be resolved including property shading. Properties defined nearest to the template to be generated will take precedence.\nIn addition, a cobigen.properties file can be specified in the target folder root (in eclipse plugin, this is equal to the source project root). These properties take precedence over template properties specified in the template folder.\n\n\n\n\n\n\n\n\nIt is not allowed to override context variables in cobigen.properties specifications as we have not found any interesting use case. This is most probably an error of the template designer, CobiGen will raise an error in this case.\n\n\n\n\n\nMulti module support or template target path redirects\n\nsince cobigen-core-4.0.0`\nOne special property you can specify in the template properties is the property `relocate. It will cause the current folder and its sub-folders to be relocated at destination path resolution time. Take the following example:\n\n\n\n\n\n\n\nLet the cobigen.properties file contain the line relocate=../sub2/${cwd}. Given that, the relative destination path of Template.java.ftl will be resolved to folder/sub2/Template.java. Compare template scan configuration for more information about basic path resolution. The relocate property specifies a relative path from the location of the cobigen.properties. The ${cwd} placeholder will contain the remaining relative path from the cobigen.properties location to the template file. In this basic example it just contains Template.java.ftl, but it may even be any relative path including sub-folders of sub1 and its templates.\nGiven the relocate feature, you can even step out of the root path, which in general is the project/maven module the input is located in. This enables template designers to even address, e.g., maven modules located next to the module the input is coming from.\n\n\n\n\nBasic Template Model\n\nIn addition to what is served by the different model builders of the different plug-ins, CobiGen provides a minimal model based on context variables as well as CobiGen properties. The following model is independent of the input format and will be served as a template model all the time:\n\n\n\n\nvariables\n\n\n\nall triggered context variables mapped to its assigned/mapped value\n\n\nall template properties\n\n\n\n\n\nall simple names of Java template logic implementation classes\n\n\nall full qualified names of Java template logic implementation classes\n\n\nfurther input related model, e.g. model from Java inputs\n\n\n\n\n\nPlugin Mechanism\n\nSince cobigen-core 4.1.0, we changed the plug-in discovery mechanism. So far it was necessary to register new plugins programmatically, which introduces the need to let every tool integration, i.e. for eclipse or maven, be dependent on every plug-in, which should be released. This made release cycles take long time as all plug-ins have to be integrated into a final release of maven or eclipse integration.\n\n\nNow, plug-ins are automatically discovered by the Java Service Loader mechanism from the classpath. This also effects the setup of eclipse and maven integration to allow modular releases of CobiGen in future. We are now able to provide faster rollouts of bug-fixes in any of the plug-ins as they can be released completely independently.\n\n\n\n\n"}