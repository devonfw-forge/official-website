{"type":"doc","filename":"devonfw-guide_devon4j.wiki_guide-jpa.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_guide-jpa-query.asciidoc","title":"Queries","breadcrumbs":["Java","General","Java Persistence API"],"text":"Queries\n\nThe Java Persistence API (JPA) defines its own query language, the java persistence query language (JPQL) (see also JPQL tutorial), which is similar to SQL but operates on entities and their attributes instead of tables and columns.\n\n\nThe simplest CRUD-Queries (e.g. find an entity by its ID) are already build in the devonfw CRUD functionality (via Repository or DAO). For other cases you need to write your own query. We distinguish between static and dynamic queries. Static queries have a fixed JPQL query string that may only use parameters to customize the query at runtime. Instead, dynamic queries can change their clauses (WHERE, ORDER BY, JOIN, etc.) at runtime depending on the given search criteria.\n\n\nStatic Queries\n\nE.g. to find all DishEntries (from MTS sample app) that have a price not exceeding a given maxPrice we write the following JPQL query:\n\n\n\n\n\n\n\nHere dish is used as alias (variable name) for our selected DishEntity (what refers to the simple name of the Java entity class). With dish.price we are referring to the Java property price (getPrice()/setPrice(…​)) in DishEntity. A named variable provided from outside (the search criteria at runtime) is specified with a colon (:) as prefix. Here with :maxPrice we reference to a variable that needs to be set via query.setParameter(\"maxPrice\", maxPriceValue). JPQL also supports indexed parameters (?) but they are discouraged because they easily cause confusion and mistakes.\n\n\nUsing Queries to Avoid Bidirectional Relationships\n\nWith the usage of queries it is possible to avoid exposing relationships or modelling bidirectional relationships, which have some disadvantages (see relationships). This is especially desired for relationships between entities of different business components.\nSo for example to get all OrderLineEntities for a specific OrderEntity without using the orderLines relation from OrderEntity the following query could be used:\n\n\n\n\n\n\n\n\n\nDynamic Queries\n\nFor dynamic queries, we use the JPA module for Querydsl. Querydsl also supports other modules such as MongoDB, and Apache Lucene. It allows to implement queries in a powerful but readable and type-safe way (unlike Criteria API). If you already know JPQL, you will quickly be able to read and write Querydsl code. It feels like JPQL but implemented in Java instead of plain text.\n\n\nTo use Querydsl in your Maven project, add the following dependencies:\n\n\n\n\n\n\n\nNext, configure the annotation processing tool (APT) plugin:\n\n\n\n\n\n\n\nHere is an example from our sample application:\n\n\n\n\n\n\n\nIn this example, we use the so called Q-types (QDishEntity). These are classes generated at build time by the Querydsl annotation processor from entity classes. The Q-type classes can be used as static types representative of the original entity class.\n\n\nThe query.from(dish) method call defines the query source, in this case the dish table. The where method defines a filter. For example, The first call uses the goe operator to filter out any dishes that are not greater or equal to the minimal price. Further operators can be found here.\n\n\nThe orderBy method is used to sort the query results according to certain criteria. Here, we sort the results first by their price and then by their name, both in ascending order. To sort in descending order, use .desc(). To partition query results into groups of rows, see the groupBy method.\n\n\nFor spring, devon4j provides another approach that you can use for your Spring applications to implement Querydsl logic without having to use these metaclasses. An example can be found here.\n\n\n\nNative Queries\n\nSpring Data supports the use of native queries. Native queries use simple native SQL syntax that is not parsed in JPQL. This allows you to use all the features that your database supports.\nThe downside to this is that database portability is lost due to the absence of an abstraction layer. Therefore, the queries may not work with another database because it may use a different syntax.\n\n\nYou can implement a native query using @Query annotation with the nativeQuery attribute set to true:\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nThis will not work with Quarkus because Quarkus does not support native queries by using the @Query annotation (see here).\n\n\n\n\n\nYou can also implement native queries directly using the EntityManager API and the createNativeQuery method.\nThis approach also works with Quarkus.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nBe sure to use the name of the table when using native queries, while you must use the entity name when implementing queries with JPQL.\n\n\n\n\n\n\nUsing Wildcards\n\nFor flexible queries it is often required to allow wildcards (especially in dynamic queries). While users intuitively expect glob syntax, the SQL and JPQL standards work differently. Therefore, a mapping is required. devonfw provides this on a lower level with LikePatternSyntax and on a higher level with QueryUtil (see QueryHelper.newStringClause(…​)).\n\n\n\nPagination\n\nWhen dealing with large amounts of data, an efficient method of retrieving the data is required. Fetching the entire data set each time would be too time consuming. Instead, Paging is used to process only small subsets of the entire data set.\n\n\nIf you are using Spring Data repositories you will get pagination support out of the box by providing the interfaces Page and  Pageable:\n\n\nListing 6. repository\n\n\n\n\n\nThen you can create a Pageable object and pass it to the method call as follows:\n\n\n\n\n\n\n\nPaging with Querydsl\n\nPagination is also supported for dynamic queries with Querydsl:\n\n\n\n\n\n\n\n\nPagination example\n\nFor the table entity we can make a search request by accessing the REST endpoint with pagination support like in the following examples:\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nAs we are requesting with the total property set to true the server responds with the total count of rows for the query.\n\n\n\n\n\nFor retrieving a concrete page, we provide the page attribute with the desired value. Here we also left out the total property so the server doesn’t incur on the effort to calculate it:\n\n\n\n\n\n\n\n\nPagingation in devon4j-spring\n\nFor spring applications, devon4j also offers its own solution for pagination. You can find an example of this here.\n\n\n\n\nQuery Meta-Parameters\n\nQueries can have meta-parameters and that are provided via SearchCriteriaTo. Besides paging (see above) we also get timeout support.\n\n\n\nAdvanced Queries\n\nWriting queries can sometimes get rather complex. The current examples given above only showed very simple basics. Within this topic a lot of advanced features need to be considered like:\n\n\n\n\nJoins\n\n\nConstructor queries\n\n\nOrder By (Sorting)\n\n\nGrouping\n\n\nHaving\n\n\nUnions\n\n\nSub-Queries\n\n\nAggregation functions like e.g. count/avg/sum\n\n\nDistinct selections\n\n\nSQL Hints (see e.g. Oracle hints or SQL-Server hints) - only when required for ultimate performance tuning\n\n\n\n\nThis list is just containing the most important aspects. As we can not cover all these topics here, they are linked to external documentation that can help and guide you.\n\n\n\n\n\n"}