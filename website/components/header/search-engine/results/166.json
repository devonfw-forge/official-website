{"type":"doc","filename":"devonfw-guide_devon4j.wiki_guide-jpa.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_guide-dao.asciidoc","title":"Data Access Object","breadcrumbs":["Java","General","Java Persistence API"],"text":"Data Access Object\n\nThe Data Access Objects (DAOs) are part of the persistence layer.\nThey are responsible for a specific entity and should be named «Entity»Dao and «Entity»DaoImpl.\nThe DAO offers the so called CRUD-functionalities (create, retrieve, update, delete) for the corresponding entity.\nAdditionally a DAO may offer advanced operations such as query or locking methods.\n\n\nDAO Interface\n\nFor each DAO there is an interface named «Entity»Dao that defines the API. For CRUD support and common naming we derive it from the ApplicationDao interface that comes with the devon application template:\n\n\n\n\n\n\n\nAll CRUD operations are inherited from ApplicationDao so you only have to declare the additional methods.\n\n\n\nDAO Implementation\n\nImplementing a DAO is quite simple. We create a class named «Entity»DaoImpl that extends ApplicationDaoImpl and implements your «Entity»Dao interface:\n\n\n\n\n\n\n\nAgain you only need to implement the additional non-CRUD methods that you have declared in your «Entity»Dao interface.\nIn the DAO implementation you can use the method getEntityManager() to access the EntityManager from the JPA. You will need the EntityManager to create and execute queries.\n\n\nStatic queries for DAO Implementation\n\nAll static queries are declared in the file src\\main\\resources\\META-INF\\orm.xml:\n\n\n\n\n\n\n\nWhen your application is started, all these static queries will be created as prepared statements. This allows better performance and also ensures that you get errors for invalid JPQL queries when you start your app rather than later when the query is used.\n\n\nTo avoid redundant occurrences of the query name (get.open.order.positions.for.order) we define a constant for each named query:\n\n\n\n\n\n\n\nNote that changing the name of the java constant (FIND_DISH_WITH_MAX_PRICE) can be done easily with refactoring. Further you can trace where the query is used by searching the references of the constant.\n\n\nThe following listing shows how to use this query:\n\n\n\n\n\n\n\nVia EntityManager.createNamedQuery(String) we create an instance of Query for our predefined static query.\nNext we use setParameter(String, Object) to provide a parameter (maxPrice) to the query. This has to be done for all parameters of the query.\n\n\nNote that using the createQuery(String) method, which takes the entire query as string (that may already contain the parameter) is not allowed to avoid SQL injection vulnerabilities.\nWhen the method getResultList() is invoked, the query is executed and the result is delivered as List. As an alternative, there is a method called getSingleResult(), which returns the entity if the query returned exactly one and throws an exception otherwise.\n\n\n\n\n\n\n"}