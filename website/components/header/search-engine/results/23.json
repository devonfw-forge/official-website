{"type":"doc","filename":"asciidoc_devonfw-guide_devon4j.wiki_devon4j.asciidoc_guides_2.html","anchor":"devonfw-guide_devon4j.wiki_quarkus_getting-started-for-spring-developers.asciidoc","title":"Getting started with Quarkus for Spring developers","breadcrumbs":["Java","Quarkus","Guides"],"text":"Getting started with Quarkus for Spring developers\n\nAs a Spring developer, you have heard more and more about Quarkus: its pros and cons, its fast growth etc. So, you decided to adopt/try Quarkus for your (next) project(s) and are wondering where to go next and what you need to pay attention to when moving from Spring to Quarkus.\n\n\nThis guide tries to address this exact concern. In the following, we will present you some main points you should be aware of when starting to develop with Quarkus, along with some useful sources.\n\n\n\n\nQuarkus is a fairly new Java toolkit. Thus, it is very well documented. It also provides a set of well-written technical guides that are a good starting point to get in touch and make the first steps with Quarkus. See here. It is an Open Source project licensed under the Apache License version 2.0. The source code is hosted in GitHub. If you have any questions or concerns, don’t hesitate to reach out to the Quarkus community.\n\n\nSame as Spring Initializr, you can go to code.quarkus.io to create a new application. Also, check out our Template Quarkus Guide to see our recommendations on certain topics.\n\n\nIn Spring stack, we recommend structuring your application into multiple modules, known as our classic structure. Moving to Quarkus and the world of cloud-native microservices, where we build smaller applications compared to monoliths, we recommend keeping everything top-level and simple. Therefore, we propose the modern structure as a better fit.\n\n\nQuarkus focuses not only on delivering top features, but also on the developer experience. The Quarkus’s Live Coding feature automatically detects changes made to Java files, application configuration, static resources, or even classpath dependency changes and recompiles and redeploys the changes. As that, it solves the problem of traditional Java development workflow, hence improves productivity.\n\n\n\n\n\n\nYou can use this feature out of the box without any extra setup by running:\n\n\n\n\n\n\n\nAnother highlight feature to speed up developing is the Quarkus’s Dev Mode with Dev Services, which can automatically provision unconfigured services in development and test mode. This means that if you include an extension and don’t configure it, Quarkus will automatically start the relevant service and wire up your application to use it, therefore saving you a lot of time setting up those services manually. In production mode, where the real configuration is provided, Dev Services will be disabled automatically.\n\n\nAdditionally, you can access the Dev UI at \\q\\dev in Dev Mode to browse endpoints offered by various extensions, conceptually similar to what a Spring Boot actuator might provide.\n\n\n\nQuarkus is made of a small core on which hundreds of extensions rely. In fact, the power of Quarkus is its extension mechanism. Think of these extensions as your project dependencies. You can add it per dependency manager such as maven or gradle.\n\n\n\n\n\n\nLike Spring Boot, Quarkus also has a vast ecosystem of extensions with commonly-used technologies.\n\n\nTable 54. Example of common Quarkus extensions and the Spring Boot Starters with similar functionality (book: Quarkus for Spring Developer)\n\n\n\n\n\n\nQuarkus extension\nSpring Boot Starter\n\n\n\n\nquarkus-resteasy-jackson\nspring-boot-starter-web\nspring-boot-starter-webflux\n\n\nquarkus-resteasy-reactive-jackson\nspring-boot-starter-web\nspring-boot-starter-webflux\n\n\nquarkus-hibernate-orm-panache\nspring-boot-starter-data-jpa\n\n\nquarkus-hibernate-orm-rest-datapanache\nspring-boot-starter-data-rest\n\n\nquarkus-hibernate-reactive-panache\nspring-boot-starter-data-r2dbc\n\n\nquarkus-mongodb-panache\nspring-boot-starter-data-mongodb\nspring-boot-starter-data-mongodb-reactive\n\n\nquarkus-hibernate-validator\nspring-boot-starter-validation\n\n\nquarkus-qpid-jms\nspring-boot-starter-activemq\n\n\nquarkus-artemis-jms\nspring-boot-starter-artemis\n\n\nquarkus-cache\nspring-boot-starter-cache\n\n\nquarkus-redis-client\nspring-boot-starter-data-redis\nspring-boot-starter-data-redis-reactive\n\n\nquarkus-mailer\nspring-boot-starter-mail\n\n\nquarkus-quartz\nspring-boot-starter-quartz\n\n\nquarkus-oidc\nspring-boot-starter-oauth2-resource-server\n\n\nquarkus-oidc-client\nspring-boot-starter-oauth2-client\n\n\nquarkus-smallrye-jwt\nspring-boot-starter-security\n\n\n\n\nA full list of all Quarkus extensions can be found here. Furthermore, you can check out the community extensions hosted by Quarkiverse Hub. Quarkus has some extensions for Spring API as well, which is helpful when migrating from Spring to Quarkus.\n\n\n\n\nQuarkus Extension for Spring Dependency Injection\n\n\nQuarkus Extension for Spring Web\n\n\nQuarkus Extension for Spring Data JPA\n\n\nQuarkus Extension for Spring Security\n\n\nQuarkus Extension for Spring Boot Properties\n\n\nQuarkus Extension for Spring Cache\n\n\nQuarkus Extension for Spring Cloud Config Client\n\n\nQuarkus Extension for Spring Data REST\n\n\nQuarkus Extension for Spring Scheduled\n\n\n\n\nBesides extensions, which are officially maintained by Quarkus team, Quarkus allows adding external libraries too. While extensions can be integrated seamlessly into Quarkus, as they can be processed at build time and be built in native mode with GraalVM, external dependencies might not work out of the box with native compilation. If that is the case, you have to recompile them with the right GraalVM configuration to make them work.\n\n\n\nQuarkus' design accounted for native compilation by default. A Quarkus native executable starts much faster and utilizes far less memory than a traditional JVM (see our performace comparision between Spring and Quarkus). To get familiar with building native executable, configuring and running it, please check out our Native Image Guide. Be sure to test your code in both JVM and native mode.\n\n\nBoth Quarkus and Spring include testing frameworks based on JUnit and Mockito. Thus, by design, Quarkus enables test-driven development by detecting affected tests as changes are made and automatically reruns them in background. As that, it gives developer instant feedback, hence improves productivity. To use continuous testing, execute the following command:\n\n\n\n\n\n\n\nFor the sake of performance optimization, Quarkus avoids reflection as much as possible, favoring static class binding instead. When building a native executable, it analyzes the call tree and removes all the classes/methods/fields that are not used directly. As a consequence, the elements used via reflection are not part of the call tree so they are dead code eliminated (if not called directly in other cases).\n\nA common example is the JSON library, which typically use reflection to serialize the objects to JSON. If you use them out of the box, you might encounter some errors in native mode. So, be sure to register the elements for reflection explicitly. A How-to is provided by Quarkus Registering For Reflection with practical program snippets.\n\n\n\n\n\nA very good read on the topic is the e-book Quarkus for Spring Developers by Red Hat. Another good source for direct hands-on coding tutorial is Katacoda Quarkus for Spring Boot Developers\n\n\n\n\n"}