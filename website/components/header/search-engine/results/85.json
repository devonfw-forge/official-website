{"type":"doc","filename":"devonfw-guide_devon4j.wiki_Spring-native-vs-Quarkus.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_spring-native-vs-quarkus.asciidoc_native-compilation-with-graalvm","title":"Native compilation with GraalVM","breadcrumbs":["Java","Quarkus","Spring Native vs Quarkus"],"text":"Native compilation with GraalVM\n\nQuarkus and Spring Native both use GraalVM for native compilation. Using a native image provides some key advantages, such as instant startup, instant peak performance, and reduced memory consumption. However, there are also some drawbacks: Creating a native image is a heavy process that is slower than a regular application. A native image also has fewer runtime optimizations after its warmup. Furthermore, it is less mature than the JVM and comes with some different behaviors.\n\n\nKey characteristics:\n\n\n\n\nStatic analysis of the application from the main entry point is\nperformed at build time.\n\n\nUnused parts are removed at build time.\n\n\nConfiguration required for reflection, resources, and dynamic proxies.\n\n\nClasspath is fixed at build time.\n\n\nNo class lazy loading: everything shipped in the executables will be loaded in memory on startup.\n\n\nSome code will run at build time.\n\n\n\n\nThere are limitations around some aspects of Java applications that are not fully supported\n\n\n\n"}