{"type":"doc","filename":"devonfw-guide_cobigen.wiki_master-cobigen.asciidoc_document-description.html","anchor":"devonfw-guide_cobigen.wiki_cobigen-usecases.asciidoc","title":"General use cases","breadcrumbs":[],"text":"General use cases\n\nIn addition to the selection of CobiGen applications introduced before, this chapter provides a more detailed overview about the currently implemented and maintained general use cases. These can be used by any project following a supported reference architecture such as devonfw or Register Factory.\n\n\ndevon4j\n\nWith our templates for devon4j, you can generate a whole CRUD application from a single Entity class. You save the effort for creating, DAOs, Transfer Objects, simple CRUD use cases with REST services and even the client application can be generated.\n\n\nCRUD server application for devon4j\n\nFor the server, the required files for all architectural layers (data access, logic, and service layer) can be created based on your Entity class. After the generation, you have CRUD functionality for the entity from bottom to top which can be accessed via a RESTful web service. Details are provided in the devon4j wiki or in our 'Jump the queue' reference application.\n\n\n\nCRUD client application for devon4ng\n\nBased on the REST services on the server, you can generate an Angular client or even an Ionic mobile client based on devon4ng. With the help of Node.js, you have a working client application for displaying your entities within minutes!\n\n\n\nTest data Builder for devon4j\n\nGenerating a builder pattern for POJOs to easily create test data in your tests. CobiGen is not only able to generate a plain builder pattern but rather builder, which follow a specific concept to minimize test data generation efforts in your unit tests. The following Person class as an example:\n\n\nListing 31. Person class\n\n\n\n\n\nIt is a simple POJO with a validation annotation, to indicate, that firstname should never be null. Creating this object in a test would imply to call every setter, which is kind of nasty. Therefore, the Builder Pattern has been introduced for quite a long time in software engineering, allowing to easily create POJOs with a fluent API. See below.\n\n\nListing 32. Builder pattern example\n\n\n\n\n\nThe Builder API generated by CobiGen allows you to set any setter accessible field of a POJO in a fluent way. But in addition lets assume a test, which should check the birth year as precondition for any business operation. So specifying all other fields of Person, especially firstname as it is mandatory to enter business code, would not make sense. The test behavior should just depend on the specification of the birth year and on no other data. So we would like to just provide this data to the test.\n\n\nThe Builder classes generated by CobiGen try to tackle this inconvenience by providing the ability to declare default values for any mandatory field due to validation or database constraints.\n\n\nListing 33. Builder Outline\n\n\n\n\n\nLooking at the plotted builder API generated by CobiGen, you will find two private methods. The method fillMandatoryFields will be generated by CobiGen and regenerated every time CobiGen generation will be triggered for the Person class. This method will set every automatically detected field with not null constraints to a default value. However, by implementing fillMandatoryFields_custom on your own, you can reset these values or even specify more default values for any other field of the object. Thus, running new PersonBuilder().birthyear(1909).createNew(); will create a valid object of Person, which is already pre-filled such that it does not influence the test execution besides the fact that it circumvents database and validation issues.\n\n\nThis even holds for complex data structures as indicated by address(new AddressBuilder().createNew());. Due to the use of the AddressBuilder for setting the default value for the field address, also the default values for Address will be set automatically.\n\n\nFinally, the builder API provides different methods to create new objects.\n\n\n\n\ncreateNew() just creates a new object from the builder specification and returns it.\n\n\npersist(EntityManager) will create a new object from the builder specification and persists it to the database.\n\n\npersistAndDuplicate(EntityManager, int) will create the given amount of objects from the builder specification and persists all of these. After the initial generation of each builder, you might want to adapt the method body as you will most probably not be able to persist more than one object with the same field assignments to the database due to unique constraints. Thus, please see the generated comment in the method to adapt unique fields accordingly before persisting to the database.\n\n\n\n\nCustom Builder for Business Needs\n\nCobiGen just generates basic builder for any POJO. However, for project needs you probably would like to have even more complex builders, which enable the easy generation of more complex test data which are encoded in a large object hierarchy. Therefore, the generated builders can just be seen as a tool to achieve this. You can define your own business driven builders in the same way as the generated builders, but explicitly focusing on your business needs. Just take this example as a demonstration of that idea:\n\n\n\n\n\n\n\nE.g. the method withExternalStudent() might create a person, which is a student and is flagged to be an external student. Basing this implementation on the generated builders will even assure that you would benefit from any default values you have set before. In addition, you can even imagine any more complex builder methods setting values driven your reusable testing needs based on the specific business knowledge.\n\n\n\n\n\nRegister Factory\n\nCRUD server application\n\nGenerates a CRUD application with persistence entities as inputs. This includes DAOs, TOs, use cases, as well as a CRUD JSF user interface if needed.\n\n\n\nTest data Builder\n\nAnalogous to Test data Builder for devon4J\n\n\n\nTest documentation\n\nGenerate test documentation from test classes. The input are the doclet tags of several test classes, which e.g. can specify a description, a cross-reference, or a test target description. The result currently is a csv file, which lists all tests with the corresponding meta-information. Afterwards, this file might be styled and passed to the customer if needed and it will be up-to-date every time!\n\n\n\n\n\n\n"}