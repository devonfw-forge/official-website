{"type":"doc","filename":"devonfw-guide_devon4j.wiki_architecture.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_architecture.asciidoc_application-architecture","title":"Application Architecture","breadcrumbs":["Java","General","Architecture"],"text":"Application Architecture\n\nFor the architecture of an application we distinguish the following views:\n\n\n\n\nThe Business Architecture describes an application from the business perspective. It divides the application into business components and with full abstraction of technical aspects.\n\n\nThe Technical Architecture describes an application from the technical implementation perspective. It divides the application into technical layers and defines which technical products and frameworks are used to support these layers.\n\n\nThe Infrastructure Architecture describes an application from the operational infrastructure perspective. It defines the nodes used to run the application including clustering, load-balancing and networking. This view is not explored further in this guide.\n\n\n\n\nBusiness Architecture\n\nThe business architecture divides the application into business components. A business component has a well-defined responsibility that it encapsulates. All aspects related to that responsibility have to be implemented within that business component. Further, the business architecture defines the dependencies between the business components. These dependencies need to be free of cycles. A business component exports its functionality via well-defined interfaces as a self-contained API. A business component may use another business component via its API and compliant with the dependencies defined by the business architecture.\n\n\nAs the business domain and logic of an application can be totally different, the devonfw can not define a standardized business architecture. Depending on the business domain it has to be defined from scratch or from a domain reference architecture template. For very small systems it may be suitable to define just a single business component containing all the code.\n\n\n\nTechnical Architecture\n\nThe technical architecture divides the application into technical layers based on the multilayered architecture. A layer is a unit of code with the same category such as a service or presentation logic. So, a layer is often supported by a technical framework. Each business component can therefore be split into component parts for each layer. However, a business component may not have component parts for every layer (e.g. only a presentation part that utilized logic from other components).\n\n\nAn overview of the technical reference architecture of the devonfw is given by figure \"Technical Reference Architecture\".\nIt defines the following layers visualized as horizontal boxes:\n\n\n\n\nclient layer for the front-end (GUI).\n\n\nservice layer for the services used to expose functionality of the\nback-end to the client or other consumers.\n\n\nbatch layer for exposing functionality in batch-processes (e.g. mass imports).\n\n\nlogic layer for the business logic.\n\n\ndomain layer for the data access, especially persistence (in the classic project structure this layer is named data-access layer).\n\n\n\n\nAlso, you can see the (business) components as vertical boxes (e.g. A and X) and how they are composed out of component parts each one assigned to one of the technical layers.\n\n\nFurther, there are technical components for cross-cutting aspects grouped by the gray box on the left. Here is a complete list:\n\n\n\n\nSecurity\n\n\nLogging\n\n\nMonitoring\n\n\nTransaction-Handling\n\n\nException-Handling\n\n\nInternationalization\n\n\nDependency-Injection\n\n\n\n\n\n\n\nFigure 5. Technical Reference Architecture\n\n\nPlease click on the architecture image to open it as SVG and click on the layers and cross-cutting topics to open the according documentation guide.\n\n\nWe reflect this architecture in our code as described in our coding conventions allowing a traceability of business components, use-cases, layers, etc. into the code and giving\ndevelopers a sound orientation within the project.\n\n\nFurther, the architecture diagram shows the allowed dependencies illustrated by the dark green connectors.\nWithin a business component a component part can call the next component part on the layer directly below via a dependency on its API (vertical connectors).\nWhile this is natural and obvious, it is generally forbidden to have dependencies upwards the layers\nor to skip a layer by a direct dependency on a component part two or more layers below.\nThe general dependencies allowed between business components are defined by the business architecture.\nIn our reference architecture diagram we assume that the business component A1 is allowed to depend\non component A2. Therefore, a use-case within the logic component part of A1 is allowed to call a\nuse-case from A2 via a dependency on the component API. The same applies for dialogs on the client layer.\nThis is illustrated by the horizontal connectors. Please note that persistence entities are part of the API of the data-access component part so only the logic component part of the same\nbusiness component may depend on them.\n\n\nThe technical architecture has to address non-functional requirements:\n\n\n\n\nscalability\nis established by keeping state in the client and making the server state-less (except for login session). Via load-balancers new server nodes can be added to improve performance (horizontal scaling).\n\n\navailability and reliability\nare addressed by clustering with redundant nodes avoiding any single-point-of failure. If one node fails the system is still available. Further, the software has to be robust so there are no dead-locks or other bad effects that can make the system unavailable or not reliable.\n\n\nsecurity\nis archived in the devonfw by the right templates and best-practices that avoid vulnerabilities. See security guidelines for further details.\n\n\nperformance\nis obtained by choosing the right products and proper configurations. While the actual implementation of the application matters for performance a proper design is important as it is the key to allow performance-optimizations (see e.g. caching).\n\n\n\n\nTechnology Stack\n\nThe technology stack of the devonfw is illustrated by the following table.\n\n\nTable 31. Technology Stack of devonfw\n\n\n\n\n\n\n\n\nTopic\nDetail\nStandard\nSuggested implementation\n\n\n\n\nruntime\nlanguage &amp; VM\nJava\nOracle JDK\n\n\nruntime\nservlet-container\nJEE\ntomcat\n\n\ncomponent management\ndependency injection\nJSR330 &amp; JSR250\nspring\n\n\nconfiguration\nframework\n-\nspring-boot\n\n\npersistence\nOR-mapper\nJPA\nhibernate\n\n\nbatch\nframework\nJSR352\nspring-batch\n\n\nservice\nSOAP services\nJAX-WS\nCXF\n\n\nservice\nREST services\nJAX-RS\nCXF\n\n\nlogging\nframework\nslf4j\nlogback\n\n\nvalidation\nframework\nbeanvalidation/JSR303\nhibernate-validator\n\n\nsecurity\nAuthentication &amp; Authorization\nJAAS\nspring-security\n\n\nmonitoring\nframework\nJMX\nspring\n\n\nmonitoring\nHTTP Bridge\nHTTP &amp; JSON\njolokia\n\n\nAOP\nframework\ndynamic proxies\nspring AOP\n\n\n\n\n\n\n\n\n\n\n"}