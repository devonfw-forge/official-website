{"type":"doc","filename":"devonfw-guide_devon4j.wiki_guide-dependency-injection.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_guide-dependency-injection.asciidoc_multiple-bean-implementations","title":"Multiple bean implementations","breadcrumbs":["Java","General","Dependency Injection"],"text":"Multiple bean implementations\n\nIn some cases you might have multiple implementations as beans for the same interface.\nThe following sub-sections handle the different scenarios to give you guidance.\n\n\nOnly one implementation in container\n\nIn some cases you still have only one implementation active as bean in the container at runtime.\nA typical example is that you have different implemenations for test and main usage.\nThis case is easy, as @Inject will always be unique.\nThe only thing you need to care about is how to configure your framework (spring, quarkus, etc.) to know which implementation to put in the container depending on specific configuration.\nIn spring this can be archived via the proprietary @Profile annotaiton.\n\n\n\nInjecting all of multiple implementations\n\nIn some situations you may have an interface that defines a kind of \"plugin\".\nYou can have multiple implementations in your container and want to have all of them injected.\nThen you can request a list with all the bean implementations via the interface as in the following example:\n\n\n\n\n\n\n\nYour code may iterate over all plugins (converters) and apply them sequentially.\nPlease note that the injection will fail (at least in spring), when there is no bean available to inject.\nSo you do not get an empty list injected but will get an exception on startup.\n\n\n\nInjecting one of multiple implementations\n\nAnother scenario is that you have multiple implementations in your container coexisting, but for injection you may want to choose a specific implementation.\nHere you could use the @Named annotation to specify a unique identifier for each implementation what is called qualified injection:\n\n\n\n\n\n\n\nHowever, we discovered that this pattern is not so great:\nThe identifiers in the @Named annotation are just strings that could easily break.\nYou could use constants instead but still this is not the best solution.\n\n\nIn the end you can very much simplify this by just directly injecting the implementation instead:\n\n\n\n\n\n\n\nIn case you want to strictly decouple from implementations, you can still create dedicated interfaces:\n\n\n\n\n\n\n\nHowever, as you can see this is again introducing additional boiler-plate code.\nWhile the principle to separate API and implementation and strictly decouple from implementation is valuable in general,\nyou should always consider KISS, lean, and agile in contrast and balance pros and cons instead of blindly following dogmas.\n\n\n\n\n"}