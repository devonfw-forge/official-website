{"type":"doc","filename":"devonfw-guide_devon4net.wiki_packages.asciidoc.html","anchor":"devonfw-guide_devon4net.wiki_packages.asciidoc_configuration-basics","title":"Configuration basics","breadcrumbs":[".net","Packages","Packages"],"text":"Configuration basics\n\nAny configuration for .Net Core 6.0 projects needs to be done in the Program.cs files which is placed on the startup application, but we can extract any configuration needed to an extension method and call that method from the component. As a result, the component will group everything required and the configuration will be much easier.\n\n\nExtension methods\n\nExtension methods allow you to \"add\" methods to existing types without having to create a new derived type, or modify it in any way. Although they are static methods, they are referred to as instance methods on the extended type. For C# code, there is no difference in calling a extension method and a method defined in a type.\n\n\nFor example, the next extension method will extend the class ExtendedClass and it will need an OptionalParameter instance to do some configuration:\n\n\n\n\n\n\n\nThanks to the this modifier preceeding the first parameter, we are able to call the method directly on a instance of ExtendedClass as follows:\n\n\n\n\n\n\n\nAs you can see, we don’t need that a class derived from ExtendedClass to add some methods and we don’t need those methods placed in the class itself either. This can be seen easily when extending a primitive type such as string:\n\n\n\n\n\n\n\nIn the previous example we created a method that can count words given a list of separation characters. And now we can use it over any string as follows:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRemember to reference the class so you can use the extension methods (using directive).\n\n\n\n\n\n\nOptions pattern\n\nThe options design pattern allows you to have strong typed options and provides you the ability to inject them into your services. To follow this pattern, the configuration present on the appsettings.json needs to be mapped into an object.\n\n\nThis means, the following configuration:\n\n\n\n\n\n\n\nWould need the following class:\n\n\n\n\n\n\n\nIn .Net we can easily map the configuration thanks to the Configure&lt;T&gt;() method from IServiceCollection and GetSection() method from IConfiguration. We could be loading the configuration as follows:\n\n\n\n\n\n\n\nAnd then injecting it making use of IOptions&lt;T&gt; interface:\n\n\n\n\n\n\n\nIn devon4net, there is an IServiceCollection extension available that uses the methods described above and also returns the options injected thanks to IOptions&lt;T&gt;.  So, to load the same options, we should use the following:\n\n\n\n\n\n\n\n\nDependency Injection\n\nDependency Injection is a technique for achieving Inversion of Control Principle. In .Net it is a built-in part that comes with the framework.\n\n\nUsing a service provider IServiceProvider available in .Net, we are able to add any service or option to a service stack that will be available for injection in constructors of the classes where it’s used.\n\n\nServices can be registered with one of the following lifetimes:\n\n\n\n\n\n\n\n\n\nLifetime\nDescription\nExample\n\n\nTransient\nTransient lifetime services are created each time they’re requested from the service container. Disposed at the end of the request.\nservices.AddTransient&lt;IDependency, Dependency&gt;();\n\n\nScoped\nA scoped lifetime indicates that services are created once per client request (connection).  Disposed at the end of the request.\nservices.AddScoped&lt;IDependency, Dependency&gt;();\n\n\nSingleton\nSingleton lifetime services are created either the first time they’re requested or by the developer. Every subsequent request of the service implementation from the dependency injection container uses the same instance.\nservices.AddSingleton&lt;IDependency, Dependency&gt;();\n\n\n\n\nThis injections would be done in the startup project in Program.cs file, and then injected in constructors where needed.\n\n\n\n\n"}