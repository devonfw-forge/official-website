{"type":"doc","filename":"devonfw-guide_devon4j.wiki_guide-jpa.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_guide-repository.asciidoc","title":"Spring Data","breadcrumbs":["Java","General","Java Persistence API"],"text":"Spring Data\n\nSpring Data JPA is supported by both Spring and Quarkus. However, in Quarkus this approach still has some limitations. For detailed information, see the official Quarkus Spring Data guide.\n\n\nMotivation\n\nThe benefits of Spring Data are (for examples and explanations see next sections):\n\n\n\n\nAll you need is one single repository interface for each entity. No need for a separate implementation or other code artifacts like XML descriptors, NamedQueries class, etc.\n\n\nYou have all information together in one place (the repository interface) that actually belong together (where as in the classic approach you have the static queries in an XML file, constants to them in NamedQueries class and referencing usages in DAO implementation classes).\n\n\nStatic queries are most simple to realize as you do not need to write any method body. This means you can develop faster.\n\n\nSupport for paging is already build-in. Again for static query method the is nothing you have to do except using the paging objects in the signature.\n\n\nStill you have the freedom to write custom implementations via default methods within the repository interface (e.g. for dynamic queries).\n\n\n\n\n\nDependency\n\nIn case you want to switch to or add Spring Data support to your Spring or Quarkus application, all you need is to add the respective maven dependency:\n\n\nListing 7. spring\n\n\n\n\n\nListing 8. quarkus\n\n\n\n\n\n\nRepository\n\nFor each entity «Entity»Entity an interface is created with the name «Entity»Repository extending JpaRepository.\nSuch repository is the analogy to a Data-Access-Object (DAO) used in the classic approach or when Spring Data is not an option.\n\n\nListing 9. Repository\n\n\n\n\n\nThe Spring Data repository provides some basic implementations for accessing data, e.g. returning all instances of a type (findAll) or returning an instance by its ID (findById).\n\n\n\nCustom method implementation\n\nIn addition, repositories can be enriched with additional functionality, e.g. to add QueryDSL functionality or to override the default implementations, by using so called repository fragments:\n\n\nExample\n\nThe following example shows how to write such a repository:\n\n\nListing 10. Repository\n\n\n\n\n\nListing 11. Repository fragment\n\n\n\n\n\nListing 12. Fragment implementation\n\n\n\n\n\nThis ProductRepository has the following features:\n\n\n\n\nCRUD support from Spring Data (see JavaDoc for details).\n\n\nSupport for QueryDSL integration, paging and more.\n\n\nA static query method findByTitle to find all ProductEntity instances from DB that have the given title. Please note the @Param annotation that links the method parameter with the variable inside the query (:title).\n\n\nThe same with pagination support via findByTitlePaginated method.\n\n\nA dynamic query method findByCriteria showing the QueryDSL and paging integration into Spring via a fragment implementation.\n\n\n\n\nYou can find an implementation of this ProductRepository in our Quarkus reference application.\n\n\n\n\n\nNote\n\n\nIn Quarkus, native and named queries via the @Query annotation are currently not supported\n\n\n\n\n\n\nIntegration of Spring Data in devon4j-spring\n\nFor Spring applications, devon4j offers a proprietary solution that integrates seamlessly with QueryDSL and uses default methods instead of the fragment approach. A separate guide for this can be found here.\n\n\n\nCustom methods without fragment approach\n\nThe fragment approach is a bit laborious, as three types (repository interface, fragment interface and fragment implementation) are always needed to implement custom methods.\nWe cannot simply use default methods within the repository because we cannot inject the EntityManager directly into the repository interface.\n\n\nAs a workaround, you can create a GenericRepository interface, as is done in the devon4j jpa-spring-data module.\n\n\n\n\n\n\n\n\n\n\n\n\nThen, all your repository interfaces can extend the GenericRepository and you can implement queries directly in the repository interface using default methods:\n\n\n\n\n\n\n\n\n\nDrawbacks\n\nSpring Data also has some drawbacks:\n\n\n\n\nSome kind of magic behind the scenes that are not so easy to understand. So in case you want to extend all your repositories without providing the implementation via a default method in a parent repository interface you need to deep-dive into Spring Data. We assume that you do not need that and hope what Spring Data and devon already provides out-of-the-box is already sufficient.\n\n\nThe Spring Data magic also includes guessing the query from the method name. This is not easy to understand and especially to debug. Our suggestion is not to use this feature at all and either provide a @Query annotation or an implementation via default method.\n\n\n\n\n\nLimitations in Quarkus\n\n\n\nNative and named queries are not supported using @Query annotation. You will receive something like: Build step io.quarkus.spring.data.deployment.SpringDataJPAProcessor#build threw an exception: java.lang.IllegalArgumentException: Attribute nativeQuery of @Query is currently not supported\n\n\nCustomizing the base repository for all repository interfaces in the code base, which is done in Spring Data by registering a class the extends SimpleJpaRepository\n\n\n\n\n\n\n\n"}