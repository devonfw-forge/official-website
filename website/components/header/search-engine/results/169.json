{"type":"doc","filename":"devonfw-guide_devon4j.wiki_guide-jpa.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_guide-jpa-idref.asciidoc","title":"IdRef","breadcrumbs":["Java","General","Java Persistence API"],"text":"IdRef\n\nIdRef can be used to reference other entities in TOs in order to make them type-safe and semantically more expressive.\nIt is an optional concept in devon4j for more complex applications that make intensive use of relations and foreign keys.\n\n\nMotivation\n\nAssuming you have a method signature like the following:\n\n\n\n\n\n\n\nSo what are the paremeters? What is returned?\n\n\nIdRef is just a wrapper for a Long used as foreign key. This makes our signature much more expressive and self-explanatory:\n\n\n\n\n\n\n\nNow we can easily see, that the result and the parameters are foreign-keys and which entity they are referring to via their generic type.\nWe can read the javadoc of these entities from the generic type and understand the context.\nFinally, when passing IdRef objects to such methods, we get compile errors in case we accidentally place parameters in the wrong order.\n\n\n\nIdRef and Mapping\n\nIn order to easily map relations from entities to transfer-objects and back, we can easily also put according getters and setters into our entities:\n\n\n\n\n\n\n\nNow, ensure that you have the same getters and setters for customerId in your Eto:\n\n\n\n\n\n\n\nThis way the bean-mapper can automatically map from your entity (ContractEntity) to your Eto (ContractEto) and vice-versa.\n\n\n\nJpaHelper and EntityManager access\n\nIn the above example we used JpaHelper.asEntity to convert the foreign key (IdRef&lt;Customer&gt;) to the according entity (CustomerEntity).\nThis will internally use EntityManager.getReference to properly create a JPA entity.\nThe alternative \"solution\" that may be used with Long instead of IdRef is typically:\n\n\n\n\n\n\n\nWhile this \"solution\" works is most cases, we discovered some more complex cases, where it fails with very strange hibernate exceptions.\nWhen cleanly creating the entity via EntityManager.getReference instead it is working in all cases.\nSo how can JpaHelper.asEntity as a static method access the EntityManager?\nTherefore we need to initialize this as otherwise you may see this exception:\n\n\n\n\n\n\n\nFor main usage in your application we assume that there is only one instance of EntityManager.\nTherefore we can initialize this instance during the spring boot setup.\nThis is what we provide for you in JpaInitializer for you\nwhen creating a devon4j app.\n\n\nJpaHelper and spring-test\n\nFurther, you also want your code to work in integration tests.\nSpring-test provides a lot of magic under the hood to make integration testing easy for you.\nTo boost the performance when running multiple tests, spring is smart and avoids creating the same spring-context multiple times.\nTherefore it stores these contexts so that if a test-case is executed with a specific spring-configuration that has already been setup before,\nthe same spring-context can be reused instead of creating it again.\nHowever, your tests may have multiple spring configurations leading to multiple spring-contexts.\nEven worse these tests can run in any order leading to switching between spring-contexts forth and back.\nTherefore, a static initializer during the spring boot setup can lead to strange errors as you can get the wrong EntityManager instance.\nIn order to fix such problems, we provide a solution pattern via DbTest ensuring for every test,\nthat the proper instance of EntityManager is initialized.\nTherefore you should derive directly or indirectly (e.g. via ComponentDbTest and SubsystemDbTest) from DbTesT or adopt your own way to apply this pattern to your tests, when using JpaHelper.\nThis already happens if you are extending ApplicationComponentTest or ApplicationSubsystemTest.\n\n\n\n\n\n\n\n"}