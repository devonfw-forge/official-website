{"type":"doc","filename":"devonfw-guide_devon4net.wiki_packages.asciidoc.html","anchor":"devonfw-guide_devon4net.wiki_packages.asciidoc_devon4net.infrastructure.mediatr","title":"Devon4Net.Infrastructure.MediatR","breadcrumbs":[".net","Packages","Packages"],"text":"Devon4Net.Infrastructure.MediatR\n\nThis component employs the MediatR library, which is a tool for implementing CQRS and Mediator patterns in .Net.\nMediatR handles the decoupling of the in-process sending of messages from handling messages.\n\n\nPatterns\n\n\n\nMediator pattern:\n\nThe mediator pattern is a behavioral design pattern that aids in the reduction of object dependencies. The pattern prevents the items from communicating directly with one another, forcing them to collaborate only through a mediator object. Mediator is used to decrease the communication complexity between multiple objects or classes. This pattern offers a mediator class that manages all communications between distinct classes and allows for easy code maintenance through loose coupling.\n\n\n\nCQRS pattern:\n\nThe acronym CQRS stands for Command and Query Responsibility Segregation, and it refers to a design that separates read and update processes for data storage.\nBy incorporating CQRS into your application, you may improve its performance, scalability, and security.\nThe flexibility gained by moving to CQRS enables a system to grow more effectively over time and prevents update instructions from triggering merge conflicts at the domain level.\n\n\n\n\n\nFigure 73. CQRS Diagram\n\n\nIn this figure, we can see how we may implement this design by utilizing a Relational Database for Write operations and a Materialized view of this Database that is synchronized and updated via events.\n\n\n\n\n\n\nKey Classes\n\nIn MediatR, you build a basic class that is identified as an implementation of the IRequest or IAsyncRequest interface.\nAll of the properties that are required to be in the message will be defined in your message class.\n\n\nIn the case of this component the messages are created in the ActionBase&lt;T&gt; class:\n\n\n\n\n\n\n\nThis ActionBase&lt;T&gt; class is then inherited by the CommandBase&lt;T&gt; and QueryBase&lt;T&gt; classes.\n\n\nNow that we’ve built a request message, we can develop a handler to reply to any messages of that type. We must implement the IRequestHandler or IAsyncRequestHandler interfaces, describing the input and output types.\n\n\nIn the case of this component MediatrRequestHandler&lt;TRequest, TResponse&gt; abstract class is used for making this process generecic\n\n\n\n\n\n\n\nThis interface defines a single method called Handle, which returns a Task of your output type.\nThis expects your request message object as an argument. In the MediatrRequestHandler&lt;TRequest, TResponse&gt; class has been implemented in this way.\n\n\n\n\n\n\n\nThe HandleAction method is defined in the following lines:\n\n\n\n\n\n\n\nThis method should be overridden in the application’s business layer Handlers.\n\n\n\nConfiguration\n\nComponent configuration is made on file appsettings.{environment}.json as follows:\n\n\n\n\n\n\n\n\n\n\n\n\n\nProperty\nDescription\n\n\nEnableMediatR\nTrue for enabling the use of MediatR component\n\n\nUseLocalBackup\nTrue for using a LiteDB database as a local backup for the MediatR messages\n\n\nDatabaseName\nThe name of the LiteDB database\n\n\n\n\n\nSetting up in Devon\n\nFor setting it up using the Devon4NetApi template just configure it in the appsettings.{environment}.json file.\n\n\nA template is available in the MediatRManagement folder of the Devon4Net.Application.WebAPI.Implementation Business Layer:\n\n\n\n\n\nFigure 74. MediatR Management Folder Structure\n\n\nAs we can see, this example adheres to the CQRS pattern structure, with Commands for writing methods and Queries for reading operations, as well as one handler for each method:\n\n\n\n\nCreateTodoCommand.cs:\n\n\n\n\n\n\nThe CreateTodoCommand inherits from CommandBase&lt;T&gt;, in this situation, the request message’s additional properties, such as Description of the Todo entity, will be included.\n\n\n\nGetTodoQuery.cs:\n\n\n\n\n\n\nBecause GetTodoQuery inherits from QueryBase&lt;T&gt;, an TodoId of the Todo object will be attached to the message’s properties in this case.\n\n\n\nCreateTodoHandler.cs:\n\n\n\n\n\n\nThis class must to inherit from MediatrRequestHandler&lt;TRequest, TResponse&gt; class that is explained above.\nOn first place we inject the TodoService via dependency injection using the Setup(ITodoService todoService) method, and then we overload the HandleAction(TRequest request, CancellationToken cancellationToken) method calling the service and returning the new DTO\n\n\n\nGetTodoHandler.cs:\n\nAll handlers may be configured using the same structure as CreateTodoHandler.cs. To do the required operation, just change the method called by the service.\n\n\n\n\n\n\nSetting up in other projects\n\nInstall the package in your solution using the Package Manager Console:\n\n\n\n\n\n\n\nCreate a Configuration static class in order to add the IRequestHandler services, for example:\n\n\n\n\n\n\n\nAdd the following lines in the Program.cs class:\n\n\n\n\n\n\n\nAfter adding the default settings provided in the configuration section, you may use the MediatR component in your code.\n\n\n\n\n"}