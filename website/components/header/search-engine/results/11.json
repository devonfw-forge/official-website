{"type":"doc","filename":"asciidoc_devonfw-guide_devon4j.wiki_devon4j.asciidoc_guides.html","anchor":"devonfw-guide_devon4j.wiki_guide-transferobject.asciidoc","title":"Transfer-Objects","breadcrumbs":["Java","Spring","Guides"],"text":"Transfer-Objects\n\nThe technical data model is defined in form of persistent entities.\nHowever, passing persistent entities via call-by-reference across the entire application will soon cause problems:\n\n\n\n\nChanges to a persistent entity are directly written back to the persistent store when the transaction is committed. When the entity is send across the application also changes tend to take place in multiple places endangering data sovereignty and leading to inconsistency.\n\n\nYou want to send and receive data via services across the network and have to define what section of your data is actually transferred. If you have relations in your technical model you quickly end up loading and transferring way too much data.\n\n\nModifications to your technical data model shall not automatically have impact on your external services causing incompatibilities.\n\n\n\n\nTo prevent such problems transfer-objects are used leading to a call-by-value model and decoupling changes to persistent entities.\n\n\nIn the following sections the different types of transfer-objects are explained.\nYou will find all according naming-conventions in the architecture-mapping\n\n\nTo structure your transfer objects, we recommend the following approaches:\n\n\n\n\nETO and CTO\n\n\nDTO\n\n\n\n\nAlso considering the following transfer objects in specific cases:\n\n\n\nSearchCriteriaTo\n\nFor searching we create or generate a «BusinessObject»SearchCriteriaTo representing a query to find instances of «BusinessObject».\n\nTO\n\nThere are typically transfer-objects for data that is never persistent.\nFor very generic cases these just carry the suffix To.\n\nSTO\n\nWe can potentially create separate service transfer objects (STO) (if possible named «BusinessObject»Sto) to keep the service API stable and independent of the actual data-model.\nHowever, we usually do not need this and want to keep our architecture simple.\nOnly create STOs if you need service versioning and support previous APIs or to provide legacy service technologies that require their own isolated data-model.\nIn such case you also need beanmapping between STOs and ETOs/DTOs what means extra effort and complexity that should be avoided.\n\n\n\n\n\n\n"}